// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/frontend.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2ffrontend_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_api_2ffrontend_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "api/messages.pb.h"
#include "google/api/annotations.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_api_2ffrontend_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2ffrontend_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_api_2ffrontend_2eproto;
namespace openmatch {
class AcknowledgeBackfillRequest;
struct AcknowledgeBackfillRequestDefaultTypeInternal;
extern AcknowledgeBackfillRequestDefaultTypeInternal _AcknowledgeBackfillRequest_default_instance_;
class AcknowledgeBackfillResponse;
struct AcknowledgeBackfillResponseDefaultTypeInternal;
extern AcknowledgeBackfillResponseDefaultTypeInternal _AcknowledgeBackfillResponse_default_instance_;
class CreateBackfillRequest;
struct CreateBackfillRequestDefaultTypeInternal;
extern CreateBackfillRequestDefaultTypeInternal _CreateBackfillRequest_default_instance_;
class CreateTicketRequest;
struct CreateTicketRequestDefaultTypeInternal;
extern CreateTicketRequestDefaultTypeInternal _CreateTicketRequest_default_instance_;
class DeleteBackfillRequest;
struct DeleteBackfillRequestDefaultTypeInternal;
extern DeleteBackfillRequestDefaultTypeInternal _DeleteBackfillRequest_default_instance_;
class DeleteTicketRequest;
struct DeleteTicketRequestDefaultTypeInternal;
extern DeleteTicketRequestDefaultTypeInternal _DeleteTicketRequest_default_instance_;
class GetBackfillRequest;
struct GetBackfillRequestDefaultTypeInternal;
extern GetBackfillRequestDefaultTypeInternal _GetBackfillRequest_default_instance_;
class GetTicketRequest;
struct GetTicketRequestDefaultTypeInternal;
extern GetTicketRequestDefaultTypeInternal _GetTicketRequest_default_instance_;
class UpdateBackfillRequest;
struct UpdateBackfillRequestDefaultTypeInternal;
extern UpdateBackfillRequestDefaultTypeInternal _UpdateBackfillRequest_default_instance_;
class WatchAssignmentsRequest;
struct WatchAssignmentsRequestDefaultTypeInternal;
extern WatchAssignmentsRequestDefaultTypeInternal _WatchAssignmentsRequest_default_instance_;
class WatchAssignmentsResponse;
struct WatchAssignmentsResponseDefaultTypeInternal;
extern WatchAssignmentsResponseDefaultTypeInternal _WatchAssignmentsResponse_default_instance_;
}  // namespace openmatch
PROTOBUF_NAMESPACE_OPEN
template<> ::openmatch::AcknowledgeBackfillRequest* Arena::CreateMaybeMessage<::openmatch::AcknowledgeBackfillRequest>(Arena*);
template<> ::openmatch::AcknowledgeBackfillResponse* Arena::CreateMaybeMessage<::openmatch::AcknowledgeBackfillResponse>(Arena*);
template<> ::openmatch::CreateBackfillRequest* Arena::CreateMaybeMessage<::openmatch::CreateBackfillRequest>(Arena*);
template<> ::openmatch::CreateTicketRequest* Arena::CreateMaybeMessage<::openmatch::CreateTicketRequest>(Arena*);
template<> ::openmatch::DeleteBackfillRequest* Arena::CreateMaybeMessage<::openmatch::DeleteBackfillRequest>(Arena*);
template<> ::openmatch::DeleteTicketRequest* Arena::CreateMaybeMessage<::openmatch::DeleteTicketRequest>(Arena*);
template<> ::openmatch::GetBackfillRequest* Arena::CreateMaybeMessage<::openmatch::GetBackfillRequest>(Arena*);
template<> ::openmatch::GetTicketRequest* Arena::CreateMaybeMessage<::openmatch::GetTicketRequest>(Arena*);
template<> ::openmatch::UpdateBackfillRequest* Arena::CreateMaybeMessage<::openmatch::UpdateBackfillRequest>(Arena*);
template<> ::openmatch::WatchAssignmentsRequest* Arena::CreateMaybeMessage<::openmatch::WatchAssignmentsRequest>(Arena*);
template<> ::openmatch::WatchAssignmentsResponse* Arena::CreateMaybeMessage<::openmatch::WatchAssignmentsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace openmatch {

// ===================================================================

class CreateTicketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.CreateTicketRequest) */ {
 public:
  inline CreateTicketRequest() : CreateTicketRequest(nullptr) {}
  ~CreateTicketRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateTicketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTicketRequest(const CreateTicketRequest& from);
  CreateTicketRequest(CreateTicketRequest&& from) noexcept
    : CreateTicketRequest() {
    *this = ::std::move(from);
  }

  inline CreateTicketRequest& operator=(const CreateTicketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTicketRequest& operator=(CreateTicketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTicketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTicketRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTicketRequest*>(
               &_CreateTicketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateTicketRequest& a, CreateTicketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTicketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTicketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTicketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTicketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTicketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTicketRequest& from) {
    CreateTicketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTicketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.CreateTicketRequest";
  }
  protected:
  explicit CreateTicketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketFieldNumber = 1,
  };
  // .openmatch.Ticket ticket = 1;
  bool has_ticket() const;
  private:
  bool _internal_has_ticket() const;
  public:
  void clear_ticket();
  const ::openmatch::Ticket& ticket() const;
  PROTOBUF_NODISCARD ::openmatch::Ticket* release_ticket();
  ::openmatch::Ticket* mutable_ticket();
  void set_allocated_ticket(::openmatch::Ticket* ticket);
  private:
  const ::openmatch::Ticket& _internal_ticket() const;
  ::openmatch::Ticket* _internal_mutable_ticket();
  public:
  void unsafe_arena_set_allocated_ticket(
      ::openmatch::Ticket* ticket);
  ::openmatch::Ticket* unsafe_arena_release_ticket();

  // @@protoc_insertion_point(class_scope:openmatch.CreateTicketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openmatch::Ticket* ticket_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2ffrontend_2eproto;
};
// -------------------------------------------------------------------

class DeleteTicketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.DeleteTicketRequest) */ {
 public:
  inline DeleteTicketRequest() : DeleteTicketRequest(nullptr) {}
  ~DeleteTicketRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteTicketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteTicketRequest(const DeleteTicketRequest& from);
  DeleteTicketRequest(DeleteTicketRequest&& from) noexcept
    : DeleteTicketRequest() {
    *this = ::std::move(from);
  }

  inline DeleteTicketRequest& operator=(const DeleteTicketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTicketRequest& operator=(DeleteTicketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTicketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTicketRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTicketRequest*>(
               &_DeleteTicketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeleteTicketRequest& a, DeleteTicketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteTicketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTicketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteTicketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteTicketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteTicketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteTicketRequest& from) {
    DeleteTicketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTicketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.DeleteTicketRequest";
  }
  protected:
  explicit DeleteTicketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketIdFieldNumber = 1,
  };
  // string ticket_id = 1;
  void clear_ticket_id();
  const std::string& ticket_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ticket_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ticket_id();
  PROTOBUF_NODISCARD std::string* release_ticket_id();
  void set_allocated_ticket_id(std::string* ticket_id);
  private:
  const std::string& _internal_ticket_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticket_id(const std::string& value);
  std::string* _internal_mutable_ticket_id();
  public:

  // @@protoc_insertion_point(class_scope:openmatch.DeleteTicketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticket_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2ffrontend_2eproto;
};
// -------------------------------------------------------------------

class GetTicketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.GetTicketRequest) */ {
 public:
  inline GetTicketRequest() : GetTicketRequest(nullptr) {}
  ~GetTicketRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTicketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTicketRequest(const GetTicketRequest& from);
  GetTicketRequest(GetTicketRequest&& from) noexcept
    : GetTicketRequest() {
    *this = ::std::move(from);
  }

  inline GetTicketRequest& operator=(const GetTicketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTicketRequest& operator=(GetTicketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTicketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTicketRequest* internal_default_instance() {
    return reinterpret_cast<const GetTicketRequest*>(
               &_GetTicketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetTicketRequest& a, GetTicketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTicketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTicketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTicketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTicketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTicketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTicketRequest& from) {
    GetTicketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTicketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.GetTicketRequest";
  }
  protected:
  explicit GetTicketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketIdFieldNumber = 1,
  };
  // string ticket_id = 1;
  void clear_ticket_id();
  const std::string& ticket_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ticket_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ticket_id();
  PROTOBUF_NODISCARD std::string* release_ticket_id();
  void set_allocated_ticket_id(std::string* ticket_id);
  private:
  const std::string& _internal_ticket_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticket_id(const std::string& value);
  std::string* _internal_mutable_ticket_id();
  public:

  // @@protoc_insertion_point(class_scope:openmatch.GetTicketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticket_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2ffrontend_2eproto;
};
// -------------------------------------------------------------------

class WatchAssignmentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.WatchAssignmentsRequest) */ {
 public:
  inline WatchAssignmentsRequest() : WatchAssignmentsRequest(nullptr) {}
  ~WatchAssignmentsRequest() override;
  explicit PROTOBUF_CONSTEXPR WatchAssignmentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchAssignmentsRequest(const WatchAssignmentsRequest& from);
  WatchAssignmentsRequest(WatchAssignmentsRequest&& from) noexcept
    : WatchAssignmentsRequest() {
    *this = ::std::move(from);
  }

  inline WatchAssignmentsRequest& operator=(const WatchAssignmentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchAssignmentsRequest& operator=(WatchAssignmentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchAssignmentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchAssignmentsRequest* internal_default_instance() {
    return reinterpret_cast<const WatchAssignmentsRequest*>(
               &_WatchAssignmentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WatchAssignmentsRequest& a, WatchAssignmentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchAssignmentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchAssignmentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchAssignmentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchAssignmentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchAssignmentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WatchAssignmentsRequest& from) {
    WatchAssignmentsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchAssignmentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.WatchAssignmentsRequest";
  }
  protected:
  explicit WatchAssignmentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketIdFieldNumber = 1,
  };
  // string ticket_id = 1;
  void clear_ticket_id();
  const std::string& ticket_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ticket_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ticket_id();
  PROTOBUF_NODISCARD std::string* release_ticket_id();
  void set_allocated_ticket_id(std::string* ticket_id);
  private:
  const std::string& _internal_ticket_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticket_id(const std::string& value);
  std::string* _internal_mutable_ticket_id();
  public:

  // @@protoc_insertion_point(class_scope:openmatch.WatchAssignmentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticket_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2ffrontend_2eproto;
};
// -------------------------------------------------------------------

class WatchAssignmentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.WatchAssignmentsResponse) */ {
 public:
  inline WatchAssignmentsResponse() : WatchAssignmentsResponse(nullptr) {}
  ~WatchAssignmentsResponse() override;
  explicit PROTOBUF_CONSTEXPR WatchAssignmentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchAssignmentsResponse(const WatchAssignmentsResponse& from);
  WatchAssignmentsResponse(WatchAssignmentsResponse&& from) noexcept
    : WatchAssignmentsResponse() {
    *this = ::std::move(from);
  }

  inline WatchAssignmentsResponse& operator=(const WatchAssignmentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchAssignmentsResponse& operator=(WatchAssignmentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchAssignmentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchAssignmentsResponse* internal_default_instance() {
    return reinterpret_cast<const WatchAssignmentsResponse*>(
               &_WatchAssignmentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(WatchAssignmentsResponse& a, WatchAssignmentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchAssignmentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchAssignmentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchAssignmentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchAssignmentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchAssignmentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WatchAssignmentsResponse& from) {
    WatchAssignmentsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchAssignmentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.WatchAssignmentsResponse";
  }
  protected:
  explicit WatchAssignmentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignmentFieldNumber = 1,
  };
  // .openmatch.Assignment assignment = 1;
  bool has_assignment() const;
  private:
  bool _internal_has_assignment() const;
  public:
  void clear_assignment();
  const ::openmatch::Assignment& assignment() const;
  PROTOBUF_NODISCARD ::openmatch::Assignment* release_assignment();
  ::openmatch::Assignment* mutable_assignment();
  void set_allocated_assignment(::openmatch::Assignment* assignment);
  private:
  const ::openmatch::Assignment& _internal_assignment() const;
  ::openmatch::Assignment* _internal_mutable_assignment();
  public:
  void unsafe_arena_set_allocated_assignment(
      ::openmatch::Assignment* assignment);
  ::openmatch::Assignment* unsafe_arena_release_assignment();

  // @@protoc_insertion_point(class_scope:openmatch.WatchAssignmentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openmatch::Assignment* assignment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2ffrontend_2eproto;
};
// -------------------------------------------------------------------

class AcknowledgeBackfillRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.AcknowledgeBackfillRequest) */ {
 public:
  inline AcknowledgeBackfillRequest() : AcknowledgeBackfillRequest(nullptr) {}
  ~AcknowledgeBackfillRequest() override;
  explicit PROTOBUF_CONSTEXPR AcknowledgeBackfillRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcknowledgeBackfillRequest(const AcknowledgeBackfillRequest& from);
  AcknowledgeBackfillRequest(AcknowledgeBackfillRequest&& from) noexcept
    : AcknowledgeBackfillRequest() {
    *this = ::std::move(from);
  }

  inline AcknowledgeBackfillRequest& operator=(const AcknowledgeBackfillRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcknowledgeBackfillRequest& operator=(AcknowledgeBackfillRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcknowledgeBackfillRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcknowledgeBackfillRequest* internal_default_instance() {
    return reinterpret_cast<const AcknowledgeBackfillRequest*>(
               &_AcknowledgeBackfillRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AcknowledgeBackfillRequest& a, AcknowledgeBackfillRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AcknowledgeBackfillRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcknowledgeBackfillRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcknowledgeBackfillRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcknowledgeBackfillRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcknowledgeBackfillRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcknowledgeBackfillRequest& from) {
    AcknowledgeBackfillRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcknowledgeBackfillRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.AcknowledgeBackfillRequest";
  }
  protected:
  explicit AcknowledgeBackfillRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackfillIdFieldNumber = 1,
    kAssignmentFieldNumber = 2,
  };
  // string backfill_id = 1;
  void clear_backfill_id();
  const std::string& backfill_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backfill_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backfill_id();
  PROTOBUF_NODISCARD std::string* release_backfill_id();
  void set_allocated_backfill_id(std::string* backfill_id);
  private:
  const std::string& _internal_backfill_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backfill_id(const std::string& value);
  std::string* _internal_mutable_backfill_id();
  public:

  // .openmatch.Assignment assignment = 2;
  bool has_assignment() const;
  private:
  bool _internal_has_assignment() const;
  public:
  void clear_assignment();
  const ::openmatch::Assignment& assignment() const;
  PROTOBUF_NODISCARD ::openmatch::Assignment* release_assignment();
  ::openmatch::Assignment* mutable_assignment();
  void set_allocated_assignment(::openmatch::Assignment* assignment);
  private:
  const ::openmatch::Assignment& _internal_assignment() const;
  ::openmatch::Assignment* _internal_mutable_assignment();
  public:
  void unsafe_arena_set_allocated_assignment(
      ::openmatch::Assignment* assignment);
  ::openmatch::Assignment* unsafe_arena_release_assignment();

  // @@protoc_insertion_point(class_scope:openmatch.AcknowledgeBackfillRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backfill_id_;
    ::openmatch::Assignment* assignment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2ffrontend_2eproto;
};
// -------------------------------------------------------------------

class AcknowledgeBackfillResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.AcknowledgeBackfillResponse) */ {
 public:
  inline AcknowledgeBackfillResponse() : AcknowledgeBackfillResponse(nullptr) {}
  ~AcknowledgeBackfillResponse() override;
  explicit PROTOBUF_CONSTEXPR AcknowledgeBackfillResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcknowledgeBackfillResponse(const AcknowledgeBackfillResponse& from);
  AcknowledgeBackfillResponse(AcknowledgeBackfillResponse&& from) noexcept
    : AcknowledgeBackfillResponse() {
    *this = ::std::move(from);
  }

  inline AcknowledgeBackfillResponse& operator=(const AcknowledgeBackfillResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcknowledgeBackfillResponse& operator=(AcknowledgeBackfillResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcknowledgeBackfillResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcknowledgeBackfillResponse* internal_default_instance() {
    return reinterpret_cast<const AcknowledgeBackfillResponse*>(
               &_AcknowledgeBackfillResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AcknowledgeBackfillResponse& a, AcknowledgeBackfillResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AcknowledgeBackfillResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcknowledgeBackfillResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcknowledgeBackfillResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcknowledgeBackfillResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcknowledgeBackfillResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcknowledgeBackfillResponse& from) {
    AcknowledgeBackfillResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcknowledgeBackfillResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.AcknowledgeBackfillResponse";
  }
  protected:
  explicit AcknowledgeBackfillResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketsFieldNumber = 2,
    kBackfillFieldNumber = 1,
  };
  // repeated .openmatch.Ticket tickets = 2;
  int tickets_size() const;
  private:
  int _internal_tickets_size() const;
  public:
  void clear_tickets();
  ::openmatch::Ticket* mutable_tickets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Ticket >*
      mutable_tickets();
  private:
  const ::openmatch::Ticket& _internal_tickets(int index) const;
  ::openmatch::Ticket* _internal_add_tickets();
  public:
  const ::openmatch::Ticket& tickets(int index) const;
  ::openmatch::Ticket* add_tickets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Ticket >&
      tickets() const;

  // .openmatch.Backfill backfill = 1;
  bool has_backfill() const;
  private:
  bool _internal_has_backfill() const;
  public:
  void clear_backfill();
  const ::openmatch::Backfill& backfill() const;
  PROTOBUF_NODISCARD ::openmatch::Backfill* release_backfill();
  ::openmatch::Backfill* mutable_backfill();
  void set_allocated_backfill(::openmatch::Backfill* backfill);
  private:
  const ::openmatch::Backfill& _internal_backfill() const;
  ::openmatch::Backfill* _internal_mutable_backfill();
  public:
  void unsafe_arena_set_allocated_backfill(
      ::openmatch::Backfill* backfill);
  ::openmatch::Backfill* unsafe_arena_release_backfill();

  // @@protoc_insertion_point(class_scope:openmatch.AcknowledgeBackfillResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Ticket > tickets_;
    ::openmatch::Backfill* backfill_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2ffrontend_2eproto;
};
// -------------------------------------------------------------------

class CreateBackfillRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.CreateBackfillRequest) */ {
 public:
  inline CreateBackfillRequest() : CreateBackfillRequest(nullptr) {}
  ~CreateBackfillRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateBackfillRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateBackfillRequest(const CreateBackfillRequest& from);
  CreateBackfillRequest(CreateBackfillRequest&& from) noexcept
    : CreateBackfillRequest() {
    *this = ::std::move(from);
  }

  inline CreateBackfillRequest& operator=(const CreateBackfillRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateBackfillRequest& operator=(CreateBackfillRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateBackfillRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateBackfillRequest* internal_default_instance() {
    return reinterpret_cast<const CreateBackfillRequest*>(
               &_CreateBackfillRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateBackfillRequest& a, CreateBackfillRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateBackfillRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateBackfillRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateBackfillRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateBackfillRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateBackfillRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateBackfillRequest& from) {
    CreateBackfillRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateBackfillRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.CreateBackfillRequest";
  }
  protected:
  explicit CreateBackfillRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackfillFieldNumber = 1,
  };
  // .openmatch.Backfill backfill = 1;
  bool has_backfill() const;
  private:
  bool _internal_has_backfill() const;
  public:
  void clear_backfill();
  const ::openmatch::Backfill& backfill() const;
  PROTOBUF_NODISCARD ::openmatch::Backfill* release_backfill();
  ::openmatch::Backfill* mutable_backfill();
  void set_allocated_backfill(::openmatch::Backfill* backfill);
  private:
  const ::openmatch::Backfill& _internal_backfill() const;
  ::openmatch::Backfill* _internal_mutable_backfill();
  public:
  void unsafe_arena_set_allocated_backfill(
      ::openmatch::Backfill* backfill);
  ::openmatch::Backfill* unsafe_arena_release_backfill();

  // @@protoc_insertion_point(class_scope:openmatch.CreateBackfillRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openmatch::Backfill* backfill_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2ffrontend_2eproto;
};
// -------------------------------------------------------------------

class DeleteBackfillRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.DeleteBackfillRequest) */ {
 public:
  inline DeleteBackfillRequest() : DeleteBackfillRequest(nullptr) {}
  ~DeleteBackfillRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteBackfillRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteBackfillRequest(const DeleteBackfillRequest& from);
  DeleteBackfillRequest(DeleteBackfillRequest&& from) noexcept
    : DeleteBackfillRequest() {
    *this = ::std::move(from);
  }

  inline DeleteBackfillRequest& operator=(const DeleteBackfillRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteBackfillRequest& operator=(DeleteBackfillRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteBackfillRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteBackfillRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteBackfillRequest*>(
               &_DeleteBackfillRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteBackfillRequest& a, DeleteBackfillRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteBackfillRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteBackfillRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteBackfillRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteBackfillRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteBackfillRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteBackfillRequest& from) {
    DeleteBackfillRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteBackfillRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.DeleteBackfillRequest";
  }
  protected:
  explicit DeleteBackfillRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackfillIdFieldNumber = 1,
  };
  // string backfill_id = 1;
  void clear_backfill_id();
  const std::string& backfill_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backfill_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backfill_id();
  PROTOBUF_NODISCARD std::string* release_backfill_id();
  void set_allocated_backfill_id(std::string* backfill_id);
  private:
  const std::string& _internal_backfill_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backfill_id(const std::string& value);
  std::string* _internal_mutable_backfill_id();
  public:

  // @@protoc_insertion_point(class_scope:openmatch.DeleteBackfillRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backfill_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2ffrontend_2eproto;
};
// -------------------------------------------------------------------

class GetBackfillRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.GetBackfillRequest) */ {
 public:
  inline GetBackfillRequest() : GetBackfillRequest(nullptr) {}
  ~GetBackfillRequest() override;
  explicit PROTOBUF_CONSTEXPR GetBackfillRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBackfillRequest(const GetBackfillRequest& from);
  GetBackfillRequest(GetBackfillRequest&& from) noexcept
    : GetBackfillRequest() {
    *this = ::std::move(from);
  }

  inline GetBackfillRequest& operator=(const GetBackfillRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBackfillRequest& operator=(GetBackfillRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBackfillRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBackfillRequest* internal_default_instance() {
    return reinterpret_cast<const GetBackfillRequest*>(
               &_GetBackfillRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetBackfillRequest& a, GetBackfillRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBackfillRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBackfillRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBackfillRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBackfillRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBackfillRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBackfillRequest& from) {
    GetBackfillRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBackfillRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.GetBackfillRequest";
  }
  protected:
  explicit GetBackfillRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackfillIdFieldNumber = 1,
  };
  // string backfill_id = 1;
  void clear_backfill_id();
  const std::string& backfill_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backfill_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backfill_id();
  PROTOBUF_NODISCARD std::string* release_backfill_id();
  void set_allocated_backfill_id(std::string* backfill_id);
  private:
  const std::string& _internal_backfill_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backfill_id(const std::string& value);
  std::string* _internal_mutable_backfill_id();
  public:

  // @@protoc_insertion_point(class_scope:openmatch.GetBackfillRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backfill_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2ffrontend_2eproto;
};
// -------------------------------------------------------------------

class UpdateBackfillRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.UpdateBackfillRequest) */ {
 public:
  inline UpdateBackfillRequest() : UpdateBackfillRequest(nullptr) {}
  ~UpdateBackfillRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateBackfillRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateBackfillRequest(const UpdateBackfillRequest& from);
  UpdateBackfillRequest(UpdateBackfillRequest&& from) noexcept
    : UpdateBackfillRequest() {
    *this = ::std::move(from);
  }

  inline UpdateBackfillRequest& operator=(const UpdateBackfillRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBackfillRequest& operator=(UpdateBackfillRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateBackfillRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateBackfillRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateBackfillRequest*>(
               &_UpdateBackfillRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UpdateBackfillRequest& a, UpdateBackfillRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateBackfillRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateBackfillRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateBackfillRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateBackfillRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateBackfillRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateBackfillRequest& from) {
    UpdateBackfillRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateBackfillRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.UpdateBackfillRequest";
  }
  protected:
  explicit UpdateBackfillRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackfillFieldNumber = 1,
  };
  // .openmatch.Backfill backfill = 1;
  bool has_backfill() const;
  private:
  bool _internal_has_backfill() const;
  public:
  void clear_backfill();
  const ::openmatch::Backfill& backfill() const;
  PROTOBUF_NODISCARD ::openmatch::Backfill* release_backfill();
  ::openmatch::Backfill* mutable_backfill();
  void set_allocated_backfill(::openmatch::Backfill* backfill);
  private:
  const ::openmatch::Backfill& _internal_backfill() const;
  ::openmatch::Backfill* _internal_mutable_backfill();
  public:
  void unsafe_arena_set_allocated_backfill(
      ::openmatch::Backfill* backfill);
  ::openmatch::Backfill* unsafe_arena_release_backfill();

  // @@protoc_insertion_point(class_scope:openmatch.UpdateBackfillRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openmatch::Backfill* backfill_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2ffrontend_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateTicketRequest

// .openmatch.Ticket ticket = 1;
inline bool CreateTicketRequest::_internal_has_ticket() const {
  return this != internal_default_instance() && _impl_.ticket_ != nullptr;
}
inline bool CreateTicketRequest::has_ticket() const {
  return _internal_has_ticket();
}
inline const ::openmatch::Ticket& CreateTicketRequest::_internal_ticket() const {
  const ::openmatch::Ticket* p = _impl_.ticket_;
  return p != nullptr ? *p : reinterpret_cast<const ::openmatch::Ticket&>(
      ::openmatch::_Ticket_default_instance_);
}
inline const ::openmatch::Ticket& CreateTicketRequest::ticket() const {
  // @@protoc_insertion_point(field_get:openmatch.CreateTicketRequest.ticket)
  return _internal_ticket();
}
inline void CreateTicketRequest::unsafe_arena_set_allocated_ticket(
    ::openmatch::Ticket* ticket) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ticket_);
  }
  _impl_.ticket_ = ticket;
  if (ticket) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.CreateTicketRequest.ticket)
}
inline ::openmatch::Ticket* CreateTicketRequest::release_ticket() {
  
  ::openmatch::Ticket* temp = _impl_.ticket_;
  _impl_.ticket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openmatch::Ticket* CreateTicketRequest::unsafe_arena_release_ticket() {
  // @@protoc_insertion_point(field_release:openmatch.CreateTicketRequest.ticket)
  
  ::openmatch::Ticket* temp = _impl_.ticket_;
  _impl_.ticket_ = nullptr;
  return temp;
}
inline ::openmatch::Ticket* CreateTicketRequest::_internal_mutable_ticket() {
  
  if (_impl_.ticket_ == nullptr) {
    auto* p = CreateMaybeMessage<::openmatch::Ticket>(GetArenaForAllocation());
    _impl_.ticket_ = p;
  }
  return _impl_.ticket_;
}
inline ::openmatch::Ticket* CreateTicketRequest::mutable_ticket() {
  ::openmatch::Ticket* _msg = _internal_mutable_ticket();
  // @@protoc_insertion_point(field_mutable:openmatch.CreateTicketRequest.ticket)
  return _msg;
}
inline void CreateTicketRequest::set_allocated_ticket(::openmatch::Ticket* ticket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ticket_);
  }
  if (ticket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ticket));
    if (message_arena != submessage_arena) {
      ticket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ticket, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ticket_ = ticket;
  // @@protoc_insertion_point(field_set_allocated:openmatch.CreateTicketRequest.ticket)
}

// -------------------------------------------------------------------

// DeleteTicketRequest

// string ticket_id = 1;
inline void DeleteTicketRequest::clear_ticket_id() {
  _impl_.ticket_id_.ClearToEmpty();
}
inline const std::string& DeleteTicketRequest::ticket_id() const {
  // @@protoc_insertion_point(field_get:openmatch.DeleteTicketRequest.ticket_id)
  return _internal_ticket_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTicketRequest::set_ticket_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ticket_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.DeleteTicketRequest.ticket_id)
}
inline std::string* DeleteTicketRequest::mutable_ticket_id() {
  std::string* _s = _internal_mutable_ticket_id();
  // @@protoc_insertion_point(field_mutable:openmatch.DeleteTicketRequest.ticket_id)
  return _s;
}
inline const std::string& DeleteTicketRequest::_internal_ticket_id() const {
  return _impl_.ticket_id_.Get();
}
inline void DeleteTicketRequest::_internal_set_ticket_id(const std::string& value) {
  
  _impl_.ticket_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteTicketRequest::_internal_mutable_ticket_id() {
  
  return _impl_.ticket_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteTicketRequest::release_ticket_id() {
  // @@protoc_insertion_point(field_release:openmatch.DeleteTicketRequest.ticket_id)
  return _impl_.ticket_id_.Release();
}
inline void DeleteTicketRequest::set_allocated_ticket_id(std::string* ticket_id) {
  if (ticket_id != nullptr) {
    
  } else {
    
  }
  _impl_.ticket_id_.SetAllocated(ticket_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ticket_id_.IsDefault()) {
    _impl_.ticket_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.DeleteTicketRequest.ticket_id)
}

// -------------------------------------------------------------------

// GetTicketRequest

// string ticket_id = 1;
inline void GetTicketRequest::clear_ticket_id() {
  _impl_.ticket_id_.ClearToEmpty();
}
inline const std::string& GetTicketRequest::ticket_id() const {
  // @@protoc_insertion_point(field_get:openmatch.GetTicketRequest.ticket_id)
  return _internal_ticket_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTicketRequest::set_ticket_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ticket_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.GetTicketRequest.ticket_id)
}
inline std::string* GetTicketRequest::mutable_ticket_id() {
  std::string* _s = _internal_mutable_ticket_id();
  // @@protoc_insertion_point(field_mutable:openmatch.GetTicketRequest.ticket_id)
  return _s;
}
inline const std::string& GetTicketRequest::_internal_ticket_id() const {
  return _impl_.ticket_id_.Get();
}
inline void GetTicketRequest::_internal_set_ticket_id(const std::string& value) {
  
  _impl_.ticket_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTicketRequest::_internal_mutable_ticket_id() {
  
  return _impl_.ticket_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTicketRequest::release_ticket_id() {
  // @@protoc_insertion_point(field_release:openmatch.GetTicketRequest.ticket_id)
  return _impl_.ticket_id_.Release();
}
inline void GetTicketRequest::set_allocated_ticket_id(std::string* ticket_id) {
  if (ticket_id != nullptr) {
    
  } else {
    
  }
  _impl_.ticket_id_.SetAllocated(ticket_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ticket_id_.IsDefault()) {
    _impl_.ticket_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.GetTicketRequest.ticket_id)
}

// -------------------------------------------------------------------

// WatchAssignmentsRequest

// string ticket_id = 1;
inline void WatchAssignmentsRequest::clear_ticket_id() {
  _impl_.ticket_id_.ClearToEmpty();
}
inline const std::string& WatchAssignmentsRequest::ticket_id() const {
  // @@protoc_insertion_point(field_get:openmatch.WatchAssignmentsRequest.ticket_id)
  return _internal_ticket_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchAssignmentsRequest::set_ticket_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ticket_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.WatchAssignmentsRequest.ticket_id)
}
inline std::string* WatchAssignmentsRequest::mutable_ticket_id() {
  std::string* _s = _internal_mutable_ticket_id();
  // @@protoc_insertion_point(field_mutable:openmatch.WatchAssignmentsRequest.ticket_id)
  return _s;
}
inline const std::string& WatchAssignmentsRequest::_internal_ticket_id() const {
  return _impl_.ticket_id_.Get();
}
inline void WatchAssignmentsRequest::_internal_set_ticket_id(const std::string& value) {
  
  _impl_.ticket_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WatchAssignmentsRequest::_internal_mutable_ticket_id() {
  
  return _impl_.ticket_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WatchAssignmentsRequest::release_ticket_id() {
  // @@protoc_insertion_point(field_release:openmatch.WatchAssignmentsRequest.ticket_id)
  return _impl_.ticket_id_.Release();
}
inline void WatchAssignmentsRequest::set_allocated_ticket_id(std::string* ticket_id) {
  if (ticket_id != nullptr) {
    
  } else {
    
  }
  _impl_.ticket_id_.SetAllocated(ticket_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ticket_id_.IsDefault()) {
    _impl_.ticket_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.WatchAssignmentsRequest.ticket_id)
}

// -------------------------------------------------------------------

// WatchAssignmentsResponse

// .openmatch.Assignment assignment = 1;
inline bool WatchAssignmentsResponse::_internal_has_assignment() const {
  return this != internal_default_instance() && _impl_.assignment_ != nullptr;
}
inline bool WatchAssignmentsResponse::has_assignment() const {
  return _internal_has_assignment();
}
inline const ::openmatch::Assignment& WatchAssignmentsResponse::_internal_assignment() const {
  const ::openmatch::Assignment* p = _impl_.assignment_;
  return p != nullptr ? *p : reinterpret_cast<const ::openmatch::Assignment&>(
      ::openmatch::_Assignment_default_instance_);
}
inline const ::openmatch::Assignment& WatchAssignmentsResponse::assignment() const {
  // @@protoc_insertion_point(field_get:openmatch.WatchAssignmentsResponse.assignment)
  return _internal_assignment();
}
inline void WatchAssignmentsResponse::unsafe_arena_set_allocated_assignment(
    ::openmatch::Assignment* assignment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.assignment_);
  }
  _impl_.assignment_ = assignment;
  if (assignment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.WatchAssignmentsResponse.assignment)
}
inline ::openmatch::Assignment* WatchAssignmentsResponse::release_assignment() {
  
  ::openmatch::Assignment* temp = _impl_.assignment_;
  _impl_.assignment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openmatch::Assignment* WatchAssignmentsResponse::unsafe_arena_release_assignment() {
  // @@protoc_insertion_point(field_release:openmatch.WatchAssignmentsResponse.assignment)
  
  ::openmatch::Assignment* temp = _impl_.assignment_;
  _impl_.assignment_ = nullptr;
  return temp;
}
inline ::openmatch::Assignment* WatchAssignmentsResponse::_internal_mutable_assignment() {
  
  if (_impl_.assignment_ == nullptr) {
    auto* p = CreateMaybeMessage<::openmatch::Assignment>(GetArenaForAllocation());
    _impl_.assignment_ = p;
  }
  return _impl_.assignment_;
}
inline ::openmatch::Assignment* WatchAssignmentsResponse::mutable_assignment() {
  ::openmatch::Assignment* _msg = _internal_mutable_assignment();
  // @@protoc_insertion_point(field_mutable:openmatch.WatchAssignmentsResponse.assignment)
  return _msg;
}
inline void WatchAssignmentsResponse::set_allocated_assignment(::openmatch::Assignment* assignment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.assignment_);
  }
  if (assignment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(assignment));
    if (message_arena != submessage_arena) {
      assignment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assignment, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.assignment_ = assignment;
  // @@protoc_insertion_point(field_set_allocated:openmatch.WatchAssignmentsResponse.assignment)
}

// -------------------------------------------------------------------

// AcknowledgeBackfillRequest

// string backfill_id = 1;
inline void AcknowledgeBackfillRequest::clear_backfill_id() {
  _impl_.backfill_id_.ClearToEmpty();
}
inline const std::string& AcknowledgeBackfillRequest::backfill_id() const {
  // @@protoc_insertion_point(field_get:openmatch.AcknowledgeBackfillRequest.backfill_id)
  return _internal_backfill_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AcknowledgeBackfillRequest::set_backfill_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.backfill_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.AcknowledgeBackfillRequest.backfill_id)
}
inline std::string* AcknowledgeBackfillRequest::mutable_backfill_id() {
  std::string* _s = _internal_mutable_backfill_id();
  // @@protoc_insertion_point(field_mutable:openmatch.AcknowledgeBackfillRequest.backfill_id)
  return _s;
}
inline const std::string& AcknowledgeBackfillRequest::_internal_backfill_id() const {
  return _impl_.backfill_id_.Get();
}
inline void AcknowledgeBackfillRequest::_internal_set_backfill_id(const std::string& value) {
  
  _impl_.backfill_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AcknowledgeBackfillRequest::_internal_mutable_backfill_id() {
  
  return _impl_.backfill_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AcknowledgeBackfillRequest::release_backfill_id() {
  // @@protoc_insertion_point(field_release:openmatch.AcknowledgeBackfillRequest.backfill_id)
  return _impl_.backfill_id_.Release();
}
inline void AcknowledgeBackfillRequest::set_allocated_backfill_id(std::string* backfill_id) {
  if (backfill_id != nullptr) {
    
  } else {
    
  }
  _impl_.backfill_id_.SetAllocated(backfill_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backfill_id_.IsDefault()) {
    _impl_.backfill_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.AcknowledgeBackfillRequest.backfill_id)
}

// .openmatch.Assignment assignment = 2;
inline bool AcknowledgeBackfillRequest::_internal_has_assignment() const {
  return this != internal_default_instance() && _impl_.assignment_ != nullptr;
}
inline bool AcknowledgeBackfillRequest::has_assignment() const {
  return _internal_has_assignment();
}
inline const ::openmatch::Assignment& AcknowledgeBackfillRequest::_internal_assignment() const {
  const ::openmatch::Assignment* p = _impl_.assignment_;
  return p != nullptr ? *p : reinterpret_cast<const ::openmatch::Assignment&>(
      ::openmatch::_Assignment_default_instance_);
}
inline const ::openmatch::Assignment& AcknowledgeBackfillRequest::assignment() const {
  // @@protoc_insertion_point(field_get:openmatch.AcknowledgeBackfillRequest.assignment)
  return _internal_assignment();
}
inline void AcknowledgeBackfillRequest::unsafe_arena_set_allocated_assignment(
    ::openmatch::Assignment* assignment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.assignment_);
  }
  _impl_.assignment_ = assignment;
  if (assignment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.AcknowledgeBackfillRequest.assignment)
}
inline ::openmatch::Assignment* AcknowledgeBackfillRequest::release_assignment() {
  
  ::openmatch::Assignment* temp = _impl_.assignment_;
  _impl_.assignment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openmatch::Assignment* AcknowledgeBackfillRequest::unsafe_arena_release_assignment() {
  // @@protoc_insertion_point(field_release:openmatch.AcknowledgeBackfillRequest.assignment)
  
  ::openmatch::Assignment* temp = _impl_.assignment_;
  _impl_.assignment_ = nullptr;
  return temp;
}
inline ::openmatch::Assignment* AcknowledgeBackfillRequest::_internal_mutable_assignment() {
  
  if (_impl_.assignment_ == nullptr) {
    auto* p = CreateMaybeMessage<::openmatch::Assignment>(GetArenaForAllocation());
    _impl_.assignment_ = p;
  }
  return _impl_.assignment_;
}
inline ::openmatch::Assignment* AcknowledgeBackfillRequest::mutable_assignment() {
  ::openmatch::Assignment* _msg = _internal_mutable_assignment();
  // @@protoc_insertion_point(field_mutable:openmatch.AcknowledgeBackfillRequest.assignment)
  return _msg;
}
inline void AcknowledgeBackfillRequest::set_allocated_assignment(::openmatch::Assignment* assignment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.assignment_);
  }
  if (assignment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(assignment));
    if (message_arena != submessage_arena) {
      assignment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assignment, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.assignment_ = assignment;
  // @@protoc_insertion_point(field_set_allocated:openmatch.AcknowledgeBackfillRequest.assignment)
}

// -------------------------------------------------------------------

// AcknowledgeBackfillResponse

// .openmatch.Backfill backfill = 1;
inline bool AcknowledgeBackfillResponse::_internal_has_backfill() const {
  return this != internal_default_instance() && _impl_.backfill_ != nullptr;
}
inline bool AcknowledgeBackfillResponse::has_backfill() const {
  return _internal_has_backfill();
}
inline const ::openmatch::Backfill& AcknowledgeBackfillResponse::_internal_backfill() const {
  const ::openmatch::Backfill* p = _impl_.backfill_;
  return p != nullptr ? *p : reinterpret_cast<const ::openmatch::Backfill&>(
      ::openmatch::_Backfill_default_instance_);
}
inline const ::openmatch::Backfill& AcknowledgeBackfillResponse::backfill() const {
  // @@protoc_insertion_point(field_get:openmatch.AcknowledgeBackfillResponse.backfill)
  return _internal_backfill();
}
inline void AcknowledgeBackfillResponse::unsafe_arena_set_allocated_backfill(
    ::openmatch::Backfill* backfill) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.backfill_);
  }
  _impl_.backfill_ = backfill;
  if (backfill) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.AcknowledgeBackfillResponse.backfill)
}
inline ::openmatch::Backfill* AcknowledgeBackfillResponse::release_backfill() {
  
  ::openmatch::Backfill* temp = _impl_.backfill_;
  _impl_.backfill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openmatch::Backfill* AcknowledgeBackfillResponse::unsafe_arena_release_backfill() {
  // @@protoc_insertion_point(field_release:openmatch.AcknowledgeBackfillResponse.backfill)
  
  ::openmatch::Backfill* temp = _impl_.backfill_;
  _impl_.backfill_ = nullptr;
  return temp;
}
inline ::openmatch::Backfill* AcknowledgeBackfillResponse::_internal_mutable_backfill() {
  
  if (_impl_.backfill_ == nullptr) {
    auto* p = CreateMaybeMessage<::openmatch::Backfill>(GetArenaForAllocation());
    _impl_.backfill_ = p;
  }
  return _impl_.backfill_;
}
inline ::openmatch::Backfill* AcknowledgeBackfillResponse::mutable_backfill() {
  ::openmatch::Backfill* _msg = _internal_mutable_backfill();
  // @@protoc_insertion_point(field_mutable:openmatch.AcknowledgeBackfillResponse.backfill)
  return _msg;
}
inline void AcknowledgeBackfillResponse::set_allocated_backfill(::openmatch::Backfill* backfill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.backfill_);
  }
  if (backfill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(backfill));
    if (message_arena != submessage_arena) {
      backfill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backfill, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.backfill_ = backfill;
  // @@protoc_insertion_point(field_set_allocated:openmatch.AcknowledgeBackfillResponse.backfill)
}

// repeated .openmatch.Ticket tickets = 2;
inline int AcknowledgeBackfillResponse::_internal_tickets_size() const {
  return _impl_.tickets_.size();
}
inline int AcknowledgeBackfillResponse::tickets_size() const {
  return _internal_tickets_size();
}
inline ::openmatch::Ticket* AcknowledgeBackfillResponse::mutable_tickets(int index) {
  // @@protoc_insertion_point(field_mutable:openmatch.AcknowledgeBackfillResponse.tickets)
  return _impl_.tickets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Ticket >*
AcknowledgeBackfillResponse::mutable_tickets() {
  // @@protoc_insertion_point(field_mutable_list:openmatch.AcknowledgeBackfillResponse.tickets)
  return &_impl_.tickets_;
}
inline const ::openmatch::Ticket& AcknowledgeBackfillResponse::_internal_tickets(int index) const {
  return _impl_.tickets_.Get(index);
}
inline const ::openmatch::Ticket& AcknowledgeBackfillResponse::tickets(int index) const {
  // @@protoc_insertion_point(field_get:openmatch.AcknowledgeBackfillResponse.tickets)
  return _internal_tickets(index);
}
inline ::openmatch::Ticket* AcknowledgeBackfillResponse::_internal_add_tickets() {
  return _impl_.tickets_.Add();
}
inline ::openmatch::Ticket* AcknowledgeBackfillResponse::add_tickets() {
  ::openmatch::Ticket* _add = _internal_add_tickets();
  // @@protoc_insertion_point(field_add:openmatch.AcknowledgeBackfillResponse.tickets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Ticket >&
AcknowledgeBackfillResponse::tickets() const {
  // @@protoc_insertion_point(field_list:openmatch.AcknowledgeBackfillResponse.tickets)
  return _impl_.tickets_;
}

// -------------------------------------------------------------------

// CreateBackfillRequest

// .openmatch.Backfill backfill = 1;
inline bool CreateBackfillRequest::_internal_has_backfill() const {
  return this != internal_default_instance() && _impl_.backfill_ != nullptr;
}
inline bool CreateBackfillRequest::has_backfill() const {
  return _internal_has_backfill();
}
inline const ::openmatch::Backfill& CreateBackfillRequest::_internal_backfill() const {
  const ::openmatch::Backfill* p = _impl_.backfill_;
  return p != nullptr ? *p : reinterpret_cast<const ::openmatch::Backfill&>(
      ::openmatch::_Backfill_default_instance_);
}
inline const ::openmatch::Backfill& CreateBackfillRequest::backfill() const {
  // @@protoc_insertion_point(field_get:openmatch.CreateBackfillRequest.backfill)
  return _internal_backfill();
}
inline void CreateBackfillRequest::unsafe_arena_set_allocated_backfill(
    ::openmatch::Backfill* backfill) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.backfill_);
  }
  _impl_.backfill_ = backfill;
  if (backfill) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.CreateBackfillRequest.backfill)
}
inline ::openmatch::Backfill* CreateBackfillRequest::release_backfill() {
  
  ::openmatch::Backfill* temp = _impl_.backfill_;
  _impl_.backfill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openmatch::Backfill* CreateBackfillRequest::unsafe_arena_release_backfill() {
  // @@protoc_insertion_point(field_release:openmatch.CreateBackfillRequest.backfill)
  
  ::openmatch::Backfill* temp = _impl_.backfill_;
  _impl_.backfill_ = nullptr;
  return temp;
}
inline ::openmatch::Backfill* CreateBackfillRequest::_internal_mutable_backfill() {
  
  if (_impl_.backfill_ == nullptr) {
    auto* p = CreateMaybeMessage<::openmatch::Backfill>(GetArenaForAllocation());
    _impl_.backfill_ = p;
  }
  return _impl_.backfill_;
}
inline ::openmatch::Backfill* CreateBackfillRequest::mutable_backfill() {
  ::openmatch::Backfill* _msg = _internal_mutable_backfill();
  // @@protoc_insertion_point(field_mutable:openmatch.CreateBackfillRequest.backfill)
  return _msg;
}
inline void CreateBackfillRequest::set_allocated_backfill(::openmatch::Backfill* backfill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.backfill_);
  }
  if (backfill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(backfill));
    if (message_arena != submessage_arena) {
      backfill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backfill, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.backfill_ = backfill;
  // @@protoc_insertion_point(field_set_allocated:openmatch.CreateBackfillRequest.backfill)
}

// -------------------------------------------------------------------

// DeleteBackfillRequest

// string backfill_id = 1;
inline void DeleteBackfillRequest::clear_backfill_id() {
  _impl_.backfill_id_.ClearToEmpty();
}
inline const std::string& DeleteBackfillRequest::backfill_id() const {
  // @@protoc_insertion_point(field_get:openmatch.DeleteBackfillRequest.backfill_id)
  return _internal_backfill_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteBackfillRequest::set_backfill_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.backfill_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.DeleteBackfillRequest.backfill_id)
}
inline std::string* DeleteBackfillRequest::mutable_backfill_id() {
  std::string* _s = _internal_mutable_backfill_id();
  // @@protoc_insertion_point(field_mutable:openmatch.DeleteBackfillRequest.backfill_id)
  return _s;
}
inline const std::string& DeleteBackfillRequest::_internal_backfill_id() const {
  return _impl_.backfill_id_.Get();
}
inline void DeleteBackfillRequest::_internal_set_backfill_id(const std::string& value) {
  
  _impl_.backfill_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteBackfillRequest::_internal_mutable_backfill_id() {
  
  return _impl_.backfill_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteBackfillRequest::release_backfill_id() {
  // @@protoc_insertion_point(field_release:openmatch.DeleteBackfillRequest.backfill_id)
  return _impl_.backfill_id_.Release();
}
inline void DeleteBackfillRequest::set_allocated_backfill_id(std::string* backfill_id) {
  if (backfill_id != nullptr) {
    
  } else {
    
  }
  _impl_.backfill_id_.SetAllocated(backfill_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backfill_id_.IsDefault()) {
    _impl_.backfill_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.DeleteBackfillRequest.backfill_id)
}

// -------------------------------------------------------------------

// GetBackfillRequest

// string backfill_id = 1;
inline void GetBackfillRequest::clear_backfill_id() {
  _impl_.backfill_id_.ClearToEmpty();
}
inline const std::string& GetBackfillRequest::backfill_id() const {
  // @@protoc_insertion_point(field_get:openmatch.GetBackfillRequest.backfill_id)
  return _internal_backfill_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBackfillRequest::set_backfill_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.backfill_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.GetBackfillRequest.backfill_id)
}
inline std::string* GetBackfillRequest::mutable_backfill_id() {
  std::string* _s = _internal_mutable_backfill_id();
  // @@protoc_insertion_point(field_mutable:openmatch.GetBackfillRequest.backfill_id)
  return _s;
}
inline const std::string& GetBackfillRequest::_internal_backfill_id() const {
  return _impl_.backfill_id_.Get();
}
inline void GetBackfillRequest::_internal_set_backfill_id(const std::string& value) {
  
  _impl_.backfill_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBackfillRequest::_internal_mutable_backfill_id() {
  
  return _impl_.backfill_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBackfillRequest::release_backfill_id() {
  // @@protoc_insertion_point(field_release:openmatch.GetBackfillRequest.backfill_id)
  return _impl_.backfill_id_.Release();
}
inline void GetBackfillRequest::set_allocated_backfill_id(std::string* backfill_id) {
  if (backfill_id != nullptr) {
    
  } else {
    
  }
  _impl_.backfill_id_.SetAllocated(backfill_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backfill_id_.IsDefault()) {
    _impl_.backfill_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.GetBackfillRequest.backfill_id)
}

// -------------------------------------------------------------------

// UpdateBackfillRequest

// .openmatch.Backfill backfill = 1;
inline bool UpdateBackfillRequest::_internal_has_backfill() const {
  return this != internal_default_instance() && _impl_.backfill_ != nullptr;
}
inline bool UpdateBackfillRequest::has_backfill() const {
  return _internal_has_backfill();
}
inline const ::openmatch::Backfill& UpdateBackfillRequest::_internal_backfill() const {
  const ::openmatch::Backfill* p = _impl_.backfill_;
  return p != nullptr ? *p : reinterpret_cast<const ::openmatch::Backfill&>(
      ::openmatch::_Backfill_default_instance_);
}
inline const ::openmatch::Backfill& UpdateBackfillRequest::backfill() const {
  // @@protoc_insertion_point(field_get:openmatch.UpdateBackfillRequest.backfill)
  return _internal_backfill();
}
inline void UpdateBackfillRequest::unsafe_arena_set_allocated_backfill(
    ::openmatch::Backfill* backfill) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.backfill_);
  }
  _impl_.backfill_ = backfill;
  if (backfill) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.UpdateBackfillRequest.backfill)
}
inline ::openmatch::Backfill* UpdateBackfillRequest::release_backfill() {
  
  ::openmatch::Backfill* temp = _impl_.backfill_;
  _impl_.backfill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openmatch::Backfill* UpdateBackfillRequest::unsafe_arena_release_backfill() {
  // @@protoc_insertion_point(field_release:openmatch.UpdateBackfillRequest.backfill)
  
  ::openmatch::Backfill* temp = _impl_.backfill_;
  _impl_.backfill_ = nullptr;
  return temp;
}
inline ::openmatch::Backfill* UpdateBackfillRequest::_internal_mutable_backfill() {
  
  if (_impl_.backfill_ == nullptr) {
    auto* p = CreateMaybeMessage<::openmatch::Backfill>(GetArenaForAllocation());
    _impl_.backfill_ = p;
  }
  return _impl_.backfill_;
}
inline ::openmatch::Backfill* UpdateBackfillRequest::mutable_backfill() {
  ::openmatch::Backfill* _msg = _internal_mutable_backfill();
  // @@protoc_insertion_point(field_mutable:openmatch.UpdateBackfillRequest.backfill)
  return _msg;
}
inline void UpdateBackfillRequest::set_allocated_backfill(::openmatch::Backfill* backfill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.backfill_);
  }
  if (backfill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(backfill));
    if (message_arena != submessage_arena) {
      backfill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backfill, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.backfill_ = backfill;
  // @@protoc_insertion_point(field_set_allocated:openmatch.UpdateBackfillRequest.backfill)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace openmatch

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_api_2ffrontend_2eproto
