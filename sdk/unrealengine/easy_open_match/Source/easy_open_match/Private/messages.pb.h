// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_api_2fmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/rpc/status.pb.h"
#include <google/protobuf/any.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_api_2fmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fmessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_api_2fmessages_2eproto;
namespace openmatch {
class Assignment;
struct AssignmentDefaultTypeInternal;
extern AssignmentDefaultTypeInternal _Assignment_default_instance_;
class Assignment_ExtensionsEntry_DoNotUse;
struct Assignment_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern Assignment_ExtensionsEntry_DoNotUseDefaultTypeInternal _Assignment_ExtensionsEntry_DoNotUse_default_instance_;
class Backfill;
struct BackfillDefaultTypeInternal;
extern BackfillDefaultTypeInternal _Backfill_default_instance_;
class Backfill_ExtensionsEntry_DoNotUse;
struct Backfill_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern Backfill_ExtensionsEntry_DoNotUseDefaultTypeInternal _Backfill_ExtensionsEntry_DoNotUse_default_instance_;
class Backfill_PersistentFieldEntry_DoNotUse;
struct Backfill_PersistentFieldEntry_DoNotUseDefaultTypeInternal;
extern Backfill_PersistentFieldEntry_DoNotUseDefaultTypeInternal _Backfill_PersistentFieldEntry_DoNotUse_default_instance_;
class DoubleRangeFilter;
struct DoubleRangeFilterDefaultTypeInternal;
extern DoubleRangeFilterDefaultTypeInternal _DoubleRangeFilter_default_instance_;
class Match;
struct MatchDefaultTypeInternal;
extern MatchDefaultTypeInternal _Match_default_instance_;
class MatchProfile;
struct MatchProfileDefaultTypeInternal;
extern MatchProfileDefaultTypeInternal _MatchProfile_default_instance_;
class MatchProfile_ExtensionsEntry_DoNotUse;
struct MatchProfile_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern MatchProfile_ExtensionsEntry_DoNotUseDefaultTypeInternal _MatchProfile_ExtensionsEntry_DoNotUse_default_instance_;
class Match_ExtensionsEntry_DoNotUse;
struct Match_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern Match_ExtensionsEntry_DoNotUseDefaultTypeInternal _Match_ExtensionsEntry_DoNotUse_default_instance_;
class Pool;
struct PoolDefaultTypeInternal;
extern PoolDefaultTypeInternal _Pool_default_instance_;
class SearchFields;
struct SearchFieldsDefaultTypeInternal;
extern SearchFieldsDefaultTypeInternal _SearchFields_default_instance_;
class SearchFields_DoubleArgsEntry_DoNotUse;
struct SearchFields_DoubleArgsEntry_DoNotUseDefaultTypeInternal;
extern SearchFields_DoubleArgsEntry_DoNotUseDefaultTypeInternal _SearchFields_DoubleArgsEntry_DoNotUse_default_instance_;
class SearchFields_StringArgsEntry_DoNotUse;
struct SearchFields_StringArgsEntry_DoNotUseDefaultTypeInternal;
extern SearchFields_StringArgsEntry_DoNotUseDefaultTypeInternal _SearchFields_StringArgsEntry_DoNotUse_default_instance_;
class StringEqualsFilter;
struct StringEqualsFilterDefaultTypeInternal;
extern StringEqualsFilterDefaultTypeInternal _StringEqualsFilter_default_instance_;
class TagPresentFilter;
struct TagPresentFilterDefaultTypeInternal;
extern TagPresentFilterDefaultTypeInternal _TagPresentFilter_default_instance_;
class Ticket;
struct TicketDefaultTypeInternal;
extern TicketDefaultTypeInternal _Ticket_default_instance_;
class Ticket_ExtensionsEntry_DoNotUse;
struct Ticket_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern Ticket_ExtensionsEntry_DoNotUseDefaultTypeInternal _Ticket_ExtensionsEntry_DoNotUse_default_instance_;
class Ticket_PersistentFieldEntry_DoNotUse;
struct Ticket_PersistentFieldEntry_DoNotUseDefaultTypeInternal;
extern Ticket_PersistentFieldEntry_DoNotUseDefaultTypeInternal _Ticket_PersistentFieldEntry_DoNotUse_default_instance_;
}  // namespace openmatch
PROTOBUF_NAMESPACE_OPEN
template<> ::openmatch::Assignment* Arena::CreateMaybeMessage<::openmatch::Assignment>(Arena*);
template<> ::openmatch::Assignment_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::openmatch::Assignment_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::openmatch::Backfill* Arena::CreateMaybeMessage<::openmatch::Backfill>(Arena*);
template<> ::openmatch::Backfill_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::openmatch::Backfill_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::openmatch::Backfill_PersistentFieldEntry_DoNotUse* Arena::CreateMaybeMessage<::openmatch::Backfill_PersistentFieldEntry_DoNotUse>(Arena*);
template<> ::openmatch::DoubleRangeFilter* Arena::CreateMaybeMessage<::openmatch::DoubleRangeFilter>(Arena*);
template<> ::openmatch::Match* Arena::CreateMaybeMessage<::openmatch::Match>(Arena*);
template<> ::openmatch::MatchProfile* Arena::CreateMaybeMessage<::openmatch::MatchProfile>(Arena*);
template<> ::openmatch::MatchProfile_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::openmatch::MatchProfile_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::openmatch::Match_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::openmatch::Match_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::openmatch::Pool* Arena::CreateMaybeMessage<::openmatch::Pool>(Arena*);
template<> ::openmatch::SearchFields* Arena::CreateMaybeMessage<::openmatch::SearchFields>(Arena*);
template<> ::openmatch::SearchFields_DoubleArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::openmatch::SearchFields_DoubleArgsEntry_DoNotUse>(Arena*);
template<> ::openmatch::SearchFields_StringArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::openmatch::SearchFields_StringArgsEntry_DoNotUse>(Arena*);
template<> ::openmatch::StringEqualsFilter* Arena::CreateMaybeMessage<::openmatch::StringEqualsFilter>(Arena*);
template<> ::openmatch::TagPresentFilter* Arena::CreateMaybeMessage<::openmatch::TagPresentFilter>(Arena*);
template<> ::openmatch::Ticket* Arena::CreateMaybeMessage<::openmatch::Ticket>(Arena*);
template<> ::openmatch::Ticket_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::openmatch::Ticket_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::openmatch::Ticket_PersistentFieldEntry_DoNotUse* Arena::CreateMaybeMessage<::openmatch::Ticket_PersistentFieldEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace openmatch {

enum DoubleRangeFilter_Exclude : int {
  DoubleRangeFilter_Exclude_NONE = 0,
  DoubleRangeFilter_Exclude_MIN = 1,
  DoubleRangeFilter_Exclude_MAX = 2,
  DoubleRangeFilter_Exclude_BOTH = 3,
  DoubleRangeFilter_Exclude_DoubleRangeFilter_Exclude_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DoubleRangeFilter_Exclude_DoubleRangeFilter_Exclude_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DoubleRangeFilter_Exclude_IsValid(int value);
constexpr DoubleRangeFilter_Exclude DoubleRangeFilter_Exclude_Exclude_MIN = DoubleRangeFilter_Exclude_NONE;
constexpr DoubleRangeFilter_Exclude DoubleRangeFilter_Exclude_Exclude_MAX = DoubleRangeFilter_Exclude_BOTH;
constexpr int DoubleRangeFilter_Exclude_Exclude_ARRAYSIZE = DoubleRangeFilter_Exclude_Exclude_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DoubleRangeFilter_Exclude_descriptor();
template<typename T>
inline const std::string& DoubleRangeFilter_Exclude_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DoubleRangeFilter_Exclude>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DoubleRangeFilter_Exclude_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DoubleRangeFilter_Exclude_descriptor(), enum_t_value);
}
inline bool DoubleRangeFilter_Exclude_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DoubleRangeFilter_Exclude* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DoubleRangeFilter_Exclude>(
    DoubleRangeFilter_Exclude_descriptor(), name, value);
}
// ===================================================================

class Ticket_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Ticket_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Ticket_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Ticket_ExtensionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Ticket_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Ticket_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Ticket_ExtensionsEntry_DoNotUse& other);
  static const Ticket_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Ticket_ExtensionsEntry_DoNotUse*>(&_Ticket_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openmatch.Ticket.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fmessages_2eproto;
};

// -------------------------------------------------------------------

class Ticket_PersistentFieldEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Ticket_PersistentFieldEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Ticket_PersistentFieldEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Ticket_PersistentFieldEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Ticket_PersistentFieldEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Ticket_PersistentFieldEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Ticket_PersistentFieldEntry_DoNotUse& other);
  static const Ticket_PersistentFieldEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Ticket_PersistentFieldEntry_DoNotUse*>(&_Ticket_PersistentFieldEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openmatch.Ticket.PersistentFieldEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fmessages_2eproto;
};

// -------------------------------------------------------------------

class Ticket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.Ticket) */ {
 public:
  inline Ticket() : Ticket(nullptr) {}
  ~Ticket() override;
  explicit PROTOBUF_CONSTEXPR Ticket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ticket(const Ticket& from);
  Ticket(Ticket&& from) noexcept
    : Ticket() {
    *this = ::std::move(from);
  }

  inline Ticket& operator=(const Ticket& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ticket& operator=(Ticket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ticket& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ticket* internal_default_instance() {
    return reinterpret_cast<const Ticket*>(
               &_Ticket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Ticket& a, Ticket& b) {
    a.Swap(&b);
  }
  inline void Swap(Ticket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ticket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ticket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ticket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ticket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ticket& from) {
    Ticket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ticket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.Ticket";
  }
  protected:
  explicit Ticket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 5,
    kPersistentFieldFieldNumber = 6,
    kIdFieldNumber = 1,
    kAssignmentFieldNumber = 3,
    kSearchFieldsFieldNumber = 4,
    kCreateTimeFieldNumber = 7,
  };
  // map<string, .google.protobuf.Any> extensions = 5;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_extensions();

  // map<string, .google.protobuf.Any> persistent_field = 6;
  int persistent_field_size() const;
  private:
  int _internal_persistent_field_size() const;
  public:
  void clear_persistent_field();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_persistent_field() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_persistent_field();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      persistent_field() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_persistent_field();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .openmatch.Assignment assignment = 3;
  bool has_assignment() const;
  private:
  bool _internal_has_assignment() const;
  public:
  void clear_assignment();
  const ::openmatch::Assignment& assignment() const;
  PROTOBUF_NODISCARD ::openmatch::Assignment* release_assignment();
  ::openmatch::Assignment* mutable_assignment();
  void set_allocated_assignment(::openmatch::Assignment* assignment);
  private:
  const ::openmatch::Assignment& _internal_assignment() const;
  ::openmatch::Assignment* _internal_mutable_assignment();
  public:
  void unsafe_arena_set_allocated_assignment(
      ::openmatch::Assignment* assignment);
  ::openmatch::Assignment* unsafe_arena_release_assignment();

  // .openmatch.SearchFields search_fields = 4;
  bool has_search_fields() const;
  private:
  bool _internal_has_search_fields() const;
  public:
  void clear_search_fields();
  const ::openmatch::SearchFields& search_fields() const;
  PROTOBUF_NODISCARD ::openmatch::SearchFields* release_search_fields();
  ::openmatch::SearchFields* mutable_search_fields();
  void set_allocated_search_fields(::openmatch::SearchFields* search_fields);
  private:
  const ::openmatch::SearchFields& _internal_search_fields() const;
  ::openmatch::SearchFields* _internal_mutable_search_fields();
  public:
  void unsafe_arena_set_allocated_search_fields(
      ::openmatch::SearchFields* search_fields);
  ::openmatch::SearchFields* unsafe_arena_release_search_fields();

  // .google.protobuf.Timestamp create_time = 7;
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // @@protoc_insertion_point(class_scope:openmatch.Ticket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Ticket_ExtensionsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Ticket_PersistentFieldEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> persistent_field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::openmatch::Assignment* assignment_;
    ::openmatch::SearchFields* search_fields_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class SearchFields_DoubleArgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SearchFields_DoubleArgsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SearchFields_DoubleArgsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  SearchFields_DoubleArgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SearchFields_DoubleArgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SearchFields_DoubleArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SearchFields_DoubleArgsEntry_DoNotUse& other);
  static const SearchFields_DoubleArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SearchFields_DoubleArgsEntry_DoNotUse*>(&_SearchFields_DoubleArgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openmatch.SearchFields.DoubleArgsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fmessages_2eproto;
};

// -------------------------------------------------------------------

class SearchFields_StringArgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SearchFields_StringArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SearchFields_StringArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SearchFields_StringArgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SearchFields_StringArgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SearchFields_StringArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SearchFields_StringArgsEntry_DoNotUse& other);
  static const SearchFields_StringArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SearchFields_StringArgsEntry_DoNotUse*>(&_SearchFields_StringArgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openmatch.SearchFields.StringArgsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openmatch.SearchFields.StringArgsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fmessages_2eproto;
};

// -------------------------------------------------------------------

class SearchFields final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.SearchFields) */ {
 public:
  inline SearchFields() : SearchFields(nullptr) {}
  ~SearchFields() override;
  explicit PROTOBUF_CONSTEXPR SearchFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchFields(const SearchFields& from);
  SearchFields(SearchFields&& from) noexcept
    : SearchFields() {
    *this = ::std::move(from);
  }

  inline SearchFields& operator=(const SearchFields& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchFields& operator=(SearchFields&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchFields& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchFields* internal_default_instance() {
    return reinterpret_cast<const SearchFields*>(
               &_SearchFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SearchFields& a, SearchFields& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchFields* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchFields* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchFields>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchFields& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchFields& from) {
    SearchFields::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchFields* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.SearchFields";
  }
  protected:
  explicit SearchFields(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDoubleArgsFieldNumber = 1,
    kStringArgsFieldNumber = 2,
    kTagsFieldNumber = 3,
  };
  // map<string, double> double_args = 1;
  int double_args_size() const;
  private:
  int _internal_double_args_size() const;
  public:
  void clear_double_args();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_double_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_double_args();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      double_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_double_args();

  // map<string, string> string_args = 2;
  int string_args_size() const;
  private:
  int _internal_string_args_size() const;
  public:
  void clear_string_args();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_string_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_string_args();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      string_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_string_args();

  // repeated string tags = 3;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // @@protoc_insertion_point(class_scope:openmatch.SearchFields)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SearchFields_DoubleArgsEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> double_args_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SearchFields_StringArgsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> string_args_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class Assignment_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Assignment_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Assignment_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Assignment_ExtensionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Assignment_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Assignment_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Assignment_ExtensionsEntry_DoNotUse& other);
  static const Assignment_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Assignment_ExtensionsEntry_DoNotUse*>(&_Assignment_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openmatch.Assignment.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fmessages_2eproto;
};

// -------------------------------------------------------------------

class Assignment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.Assignment) */ {
 public:
  inline Assignment() : Assignment(nullptr) {}
  ~Assignment() override;
  explicit PROTOBUF_CONSTEXPR Assignment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Assignment(const Assignment& from);
  Assignment(Assignment&& from) noexcept
    : Assignment() {
    *this = ::std::move(from);
  }

  inline Assignment& operator=(const Assignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Assignment& operator=(Assignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Assignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Assignment* internal_default_instance() {
    return reinterpret_cast<const Assignment*>(
               &_Assignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Assignment& a, Assignment& b) {
    a.Swap(&b);
  }
  inline void Swap(Assignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Assignment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Assignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Assignment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Assignment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Assignment& from) {
    Assignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Assignment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.Assignment";
  }
  protected:
  explicit Assignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 4,
    kConnectionFieldNumber = 1,
  };
  // map<string, .google.protobuf.Any> extensions = 4;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_extensions();

  // string connection = 1;
  void clear_connection();
  const std::string& connection() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connection(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connection();
  PROTOBUF_NODISCARD std::string* release_connection();
  void set_allocated_connection(std::string* connection);
  private:
  const std::string& _internal_connection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection(const std::string& value);
  std::string* _internal_mutable_connection();
  public:

  // @@protoc_insertion_point(class_scope:openmatch.Assignment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Assignment_ExtensionsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class DoubleRangeFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.DoubleRangeFilter) */ {
 public:
  inline DoubleRangeFilter() : DoubleRangeFilter(nullptr) {}
  ~DoubleRangeFilter() override;
  explicit PROTOBUF_CONSTEXPR DoubleRangeFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleRangeFilter(const DoubleRangeFilter& from);
  DoubleRangeFilter(DoubleRangeFilter&& from) noexcept
    : DoubleRangeFilter() {
    *this = ::std::move(from);
  }

  inline DoubleRangeFilter& operator=(const DoubleRangeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleRangeFilter& operator=(DoubleRangeFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleRangeFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleRangeFilter* internal_default_instance() {
    return reinterpret_cast<const DoubleRangeFilter*>(
               &_DoubleRangeFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DoubleRangeFilter& a, DoubleRangeFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleRangeFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleRangeFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleRangeFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleRangeFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleRangeFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleRangeFilter& from) {
    DoubleRangeFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleRangeFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.DoubleRangeFilter";
  }
  protected:
  explicit DoubleRangeFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DoubleRangeFilter_Exclude Exclude;
  static constexpr Exclude NONE =
    DoubleRangeFilter_Exclude_NONE;
  static constexpr Exclude MIN =
    DoubleRangeFilter_Exclude_MIN;
  static constexpr Exclude MAX =
    DoubleRangeFilter_Exclude_MAX;
  static constexpr Exclude BOTH =
    DoubleRangeFilter_Exclude_BOTH;
  static inline bool Exclude_IsValid(int value) {
    return DoubleRangeFilter_Exclude_IsValid(value);
  }
  static constexpr Exclude Exclude_MIN =
    DoubleRangeFilter_Exclude_Exclude_MIN;
  static constexpr Exclude Exclude_MAX =
    DoubleRangeFilter_Exclude_Exclude_MAX;
  static constexpr int Exclude_ARRAYSIZE =
    DoubleRangeFilter_Exclude_Exclude_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Exclude_descriptor() {
    return DoubleRangeFilter_Exclude_descriptor();
  }
  template<typename T>
  static inline const std::string& Exclude_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Exclude>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Exclude_Name.");
    return DoubleRangeFilter_Exclude_Name(enum_t_value);
  }
  static inline bool Exclude_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Exclude* value) {
    return DoubleRangeFilter_Exclude_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDoubleArgFieldNumber = 1,
    kMaxFieldNumber = 2,
    kMinFieldNumber = 3,
    kExcludeFieldNumber = 4,
  };
  // string double_arg = 1;
  void clear_double_arg();
  const std::string& double_arg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_double_arg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_double_arg();
  PROTOBUF_NODISCARD std::string* release_double_arg();
  void set_allocated_double_arg(std::string* double_arg);
  private:
  const std::string& _internal_double_arg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_double_arg(const std::string& value);
  std::string* _internal_mutable_double_arg();
  public:

  // double max = 2;
  void clear_max();
  double max() const;
  void set_max(double value);
  private:
  double _internal_max() const;
  void _internal_set_max(double value);
  public:

  // double min = 3;
  void clear_min();
  double min() const;
  void set_min(double value);
  private:
  double _internal_min() const;
  void _internal_set_min(double value);
  public:

  // .openmatch.DoubleRangeFilter.Exclude exclude = 4;
  void clear_exclude();
  ::openmatch::DoubleRangeFilter_Exclude exclude() const;
  void set_exclude(::openmatch::DoubleRangeFilter_Exclude value);
  private:
  ::openmatch::DoubleRangeFilter_Exclude _internal_exclude() const;
  void _internal_set_exclude(::openmatch::DoubleRangeFilter_Exclude value);
  public:

  // @@protoc_insertion_point(class_scope:openmatch.DoubleRangeFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr double_arg_;
    double max_;
    double min_;
    int exclude_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class StringEqualsFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.StringEqualsFilter) */ {
 public:
  inline StringEqualsFilter() : StringEqualsFilter(nullptr) {}
  ~StringEqualsFilter() override;
  explicit PROTOBUF_CONSTEXPR StringEqualsFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringEqualsFilter(const StringEqualsFilter& from);
  StringEqualsFilter(StringEqualsFilter&& from) noexcept
    : StringEqualsFilter() {
    *this = ::std::move(from);
  }

  inline StringEqualsFilter& operator=(const StringEqualsFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringEqualsFilter& operator=(StringEqualsFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringEqualsFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringEqualsFilter* internal_default_instance() {
    return reinterpret_cast<const StringEqualsFilter*>(
               &_StringEqualsFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StringEqualsFilter& a, StringEqualsFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(StringEqualsFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringEqualsFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringEqualsFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringEqualsFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringEqualsFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringEqualsFilter& from) {
    StringEqualsFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringEqualsFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.StringEqualsFilter";
  }
  protected:
  explicit StringEqualsFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringArgFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string string_arg = 1;
  void clear_string_arg();
  const std::string& string_arg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_arg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_arg();
  PROTOBUF_NODISCARD std::string* release_string_arg();
  void set_allocated_string_arg(std::string* string_arg);
  private:
  const std::string& _internal_string_arg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_arg(const std::string& value);
  std::string* _internal_mutable_string_arg();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:openmatch.StringEqualsFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_arg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class TagPresentFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.TagPresentFilter) */ {
 public:
  inline TagPresentFilter() : TagPresentFilter(nullptr) {}
  ~TagPresentFilter() override;
  explicit PROTOBUF_CONSTEXPR TagPresentFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagPresentFilter(const TagPresentFilter& from);
  TagPresentFilter(TagPresentFilter&& from) noexcept
    : TagPresentFilter() {
    *this = ::std::move(from);
  }

  inline TagPresentFilter& operator=(const TagPresentFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagPresentFilter& operator=(TagPresentFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagPresentFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagPresentFilter* internal_default_instance() {
    return reinterpret_cast<const TagPresentFilter*>(
               &_TagPresentFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TagPresentFilter& a, TagPresentFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(TagPresentFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagPresentFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagPresentFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagPresentFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagPresentFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TagPresentFilter& from) {
    TagPresentFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagPresentFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.TagPresentFilter";
  }
  protected:
  explicit TagPresentFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
  };
  // string tag = 1;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // @@protoc_insertion_point(class_scope:openmatch.TagPresentFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class Pool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.Pool) */ {
 public:
  inline Pool() : Pool(nullptr) {}
  ~Pool() override;
  explicit PROTOBUF_CONSTEXPR Pool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pool(const Pool& from);
  Pool(Pool&& from) noexcept
    : Pool() {
    *this = ::std::move(from);
  }

  inline Pool& operator=(const Pool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pool& operator=(Pool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pool* internal_default_instance() {
    return reinterpret_cast<const Pool*>(
               &_Pool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Pool& a, Pool& b) {
    a.Swap(&b);
  }
  inline void Swap(Pool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pool& from) {
    Pool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.Pool";
  }
  protected:
  explicit Pool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDoubleRangeFiltersFieldNumber = 2,
    kStringEqualsFiltersFieldNumber = 4,
    kTagPresentFiltersFieldNumber = 5,
    kNameFieldNumber = 1,
    kCreatedBeforeFieldNumber = 6,
    kCreatedAfterFieldNumber = 7,
  };
  // repeated .openmatch.DoubleRangeFilter double_range_filters = 2;
  int double_range_filters_size() const;
  private:
  int _internal_double_range_filters_size() const;
  public:
  void clear_double_range_filters();
  ::openmatch::DoubleRangeFilter* mutable_double_range_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::DoubleRangeFilter >*
      mutable_double_range_filters();
  private:
  const ::openmatch::DoubleRangeFilter& _internal_double_range_filters(int index) const;
  ::openmatch::DoubleRangeFilter* _internal_add_double_range_filters();
  public:
  const ::openmatch::DoubleRangeFilter& double_range_filters(int index) const;
  ::openmatch::DoubleRangeFilter* add_double_range_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::DoubleRangeFilter >&
      double_range_filters() const;

  // repeated .openmatch.StringEqualsFilter string_equals_filters = 4;
  int string_equals_filters_size() const;
  private:
  int _internal_string_equals_filters_size() const;
  public:
  void clear_string_equals_filters();
  ::openmatch::StringEqualsFilter* mutable_string_equals_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::StringEqualsFilter >*
      mutable_string_equals_filters();
  private:
  const ::openmatch::StringEqualsFilter& _internal_string_equals_filters(int index) const;
  ::openmatch::StringEqualsFilter* _internal_add_string_equals_filters();
  public:
  const ::openmatch::StringEqualsFilter& string_equals_filters(int index) const;
  ::openmatch::StringEqualsFilter* add_string_equals_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::StringEqualsFilter >&
      string_equals_filters() const;

  // repeated .openmatch.TagPresentFilter tag_present_filters = 5;
  int tag_present_filters_size() const;
  private:
  int _internal_tag_present_filters_size() const;
  public:
  void clear_tag_present_filters();
  ::openmatch::TagPresentFilter* mutable_tag_present_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::TagPresentFilter >*
      mutable_tag_present_filters();
  private:
  const ::openmatch::TagPresentFilter& _internal_tag_present_filters(int index) const;
  ::openmatch::TagPresentFilter* _internal_add_tag_present_filters();
  public:
  const ::openmatch::TagPresentFilter& tag_present_filters(int index) const;
  ::openmatch::TagPresentFilter* add_tag_present_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::TagPresentFilter >&
      tag_present_filters() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp created_before = 6;
  bool has_created_before() const;
  private:
  bool _internal_has_created_before() const;
  public:
  void clear_created_before();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_before() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_before();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_before();
  void set_allocated_created_before(::PROTOBUF_NAMESPACE_ID::Timestamp* created_before);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_before() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_before();
  public:
  void unsafe_arena_set_allocated_created_before(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_before);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_before();

  // .google.protobuf.Timestamp created_after = 7;
  bool has_created_after() const;
  private:
  bool _internal_has_created_after() const;
  public:
  void clear_created_after();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_after() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_after();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_after();
  void set_allocated_created_after(::PROTOBUF_NAMESPACE_ID::Timestamp* created_after);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_after() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_after();
  public:
  void unsafe_arena_set_allocated_created_after(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_after);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_after();

  // @@protoc_insertion_point(class_scope:openmatch.Pool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::DoubleRangeFilter > double_range_filters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::StringEqualsFilter > string_equals_filters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::TagPresentFilter > tag_present_filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_before_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_after_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class MatchProfile_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchProfile_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MatchProfile_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  MatchProfile_ExtensionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR MatchProfile_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit MatchProfile_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MatchProfile_ExtensionsEntry_DoNotUse& other);
  static const MatchProfile_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MatchProfile_ExtensionsEntry_DoNotUse*>(&_MatchProfile_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openmatch.MatchProfile.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fmessages_2eproto;
};

// -------------------------------------------------------------------

class MatchProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.MatchProfile) */ {
 public:
  inline MatchProfile() : MatchProfile(nullptr) {}
  ~MatchProfile() override;
  explicit PROTOBUF_CONSTEXPR MatchProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchProfile(const MatchProfile& from);
  MatchProfile(MatchProfile&& from) noexcept
    : MatchProfile() {
    *this = ::std::move(from);
  }

  inline MatchProfile& operator=(const MatchProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchProfile& operator=(MatchProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchProfile* internal_default_instance() {
    return reinterpret_cast<const MatchProfile*>(
               &_MatchProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MatchProfile& a, MatchProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MatchProfile& from) {
    MatchProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.MatchProfile";
  }
  protected:
  explicit MatchProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPoolsFieldNumber = 3,
    kExtensionsFieldNumber = 5,
    kNameFieldNumber = 1,
  };
  // repeated .openmatch.Pool pools = 3;
  int pools_size() const;
  private:
  int _internal_pools_size() const;
  public:
  void clear_pools();
  ::openmatch::Pool* mutable_pools(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Pool >*
      mutable_pools();
  private:
  const ::openmatch::Pool& _internal_pools(int index) const;
  ::openmatch::Pool* _internal_add_pools();
  public:
  const ::openmatch::Pool& pools(int index) const;
  ::openmatch::Pool* add_pools();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Pool >&
      pools() const;

  // map<string, .google.protobuf.Any> extensions = 5;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_extensions();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:openmatch.MatchProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Pool > pools_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        MatchProfile_ExtensionsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class Match_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Match_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Match_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Match_ExtensionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Match_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Match_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Match_ExtensionsEntry_DoNotUse& other);
  static const Match_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Match_ExtensionsEntry_DoNotUse*>(&_Match_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openmatch.Match.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fmessages_2eproto;
};

// -------------------------------------------------------------------

class Match final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.Match) */ {
 public:
  inline Match() : Match(nullptr) {}
  ~Match() override;
  explicit PROTOBUF_CONSTEXPR Match(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Match(const Match& from);
  Match(Match&& from) noexcept
    : Match() {
    *this = ::std::move(from);
  }

  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }
  inline Match& operator=(Match&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Match& default_instance() {
    return *internal_default_instance();
  }
  static inline const Match* internal_default_instance() {
    return reinterpret_cast<const Match*>(
               &_Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Match& a, Match& b) {
    a.Swap(&b);
  }
  inline void Swap(Match* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Match* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Match* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Match>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Match& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Match& from) {
    Match::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Match* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.Match";
  }
  protected:
  explicit Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTicketsFieldNumber = 4,
    kExtensionsFieldNumber = 7,
    kMatchIdFieldNumber = 1,
    kMatchProfileFieldNumber = 2,
    kMatchFunctionFieldNumber = 3,
    kBackfillFieldNumber = 8,
    kAllocateGameserverFieldNumber = 9,
  };
  // repeated .openmatch.Ticket tickets = 4;
  int tickets_size() const;
  private:
  int _internal_tickets_size() const;
  public:
  void clear_tickets();
  ::openmatch::Ticket* mutable_tickets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Ticket >*
      mutable_tickets();
  private:
  const ::openmatch::Ticket& _internal_tickets(int index) const;
  ::openmatch::Ticket* _internal_add_tickets();
  public:
  const ::openmatch::Ticket& tickets(int index) const;
  ::openmatch::Ticket* add_tickets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Ticket >&
      tickets() const;

  // map<string, .google.protobuf.Any> extensions = 7;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_extensions();

  // string match_id = 1;
  void clear_match_id();
  const std::string& match_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_match_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_match_id();
  PROTOBUF_NODISCARD std::string* release_match_id();
  void set_allocated_match_id(std::string* match_id);
  private:
  const std::string& _internal_match_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_match_id(const std::string& value);
  std::string* _internal_mutable_match_id();
  public:

  // string match_profile = 2;
  void clear_match_profile();
  const std::string& match_profile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_match_profile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_match_profile();
  PROTOBUF_NODISCARD std::string* release_match_profile();
  void set_allocated_match_profile(std::string* match_profile);
  private:
  const std::string& _internal_match_profile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_match_profile(const std::string& value);
  std::string* _internal_mutable_match_profile();
  public:

  // string match_function = 3;
  void clear_match_function();
  const std::string& match_function() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_match_function(ArgT0&& arg0, ArgT... args);
  std::string* mutable_match_function();
  PROTOBUF_NODISCARD std::string* release_match_function();
  void set_allocated_match_function(std::string* match_function);
  private:
  const std::string& _internal_match_function() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_match_function(const std::string& value);
  std::string* _internal_mutable_match_function();
  public:

  // .openmatch.Backfill backfill = 8;
  bool has_backfill() const;
  private:
  bool _internal_has_backfill() const;
  public:
  void clear_backfill();
  const ::openmatch::Backfill& backfill() const;
  PROTOBUF_NODISCARD ::openmatch::Backfill* release_backfill();
  ::openmatch::Backfill* mutable_backfill();
  void set_allocated_backfill(::openmatch::Backfill* backfill);
  private:
  const ::openmatch::Backfill& _internal_backfill() const;
  ::openmatch::Backfill* _internal_mutable_backfill();
  public:
  void unsafe_arena_set_allocated_backfill(
      ::openmatch::Backfill* backfill);
  ::openmatch::Backfill* unsafe_arena_release_backfill();

  // bool allocate_gameserver = 9;
  void clear_allocate_gameserver();
  bool allocate_gameserver() const;
  void set_allocate_gameserver(bool value);
  private:
  bool _internal_allocate_gameserver() const;
  void _internal_set_allocate_gameserver(bool value);
  public:

  // @@protoc_insertion_point(class_scope:openmatch.Match)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Ticket > tickets_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Match_ExtensionsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_profile_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_function_;
    ::openmatch::Backfill* backfill_;
    bool allocate_gameserver_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class Backfill_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Backfill_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Backfill_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Backfill_ExtensionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Backfill_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Backfill_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Backfill_ExtensionsEntry_DoNotUse& other);
  static const Backfill_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Backfill_ExtensionsEntry_DoNotUse*>(&_Backfill_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openmatch.Backfill.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fmessages_2eproto;
};

// -------------------------------------------------------------------

class Backfill_PersistentFieldEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Backfill_PersistentFieldEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Backfill_PersistentFieldEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Backfill_PersistentFieldEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Backfill_PersistentFieldEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Backfill_PersistentFieldEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Backfill_PersistentFieldEntry_DoNotUse& other);
  static const Backfill_PersistentFieldEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Backfill_PersistentFieldEntry_DoNotUse*>(&_Backfill_PersistentFieldEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openmatch.Backfill.PersistentFieldEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fmessages_2eproto;
};

// -------------------------------------------------------------------

class Backfill final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmatch.Backfill) */ {
 public:
  inline Backfill() : Backfill(nullptr) {}
  ~Backfill() override;
  explicit PROTOBUF_CONSTEXPR Backfill(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backfill(const Backfill& from);
  Backfill(Backfill&& from) noexcept
    : Backfill() {
    *this = ::std::move(from);
  }

  inline Backfill& operator=(const Backfill& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backfill& operator=(Backfill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backfill& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backfill* internal_default_instance() {
    return reinterpret_cast<const Backfill*>(
               &_Backfill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Backfill& a, Backfill& b) {
    a.Swap(&b);
  }
  inline void Swap(Backfill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backfill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backfill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backfill>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backfill& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Backfill& from) {
    Backfill::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backfill* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmatch.Backfill";
  }
  protected:
  explicit Backfill(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 3,
    kPersistentFieldFieldNumber = 4,
    kIdFieldNumber = 1,
    kSearchFieldsFieldNumber = 2,
    kCreateTimeFieldNumber = 5,
    kGenerationFieldNumber = 6,
  };
  // map<string, .google.protobuf.Any> extensions = 3;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_extensions();

  // map<string, .google.protobuf.Any> persistent_field = 4;
  int persistent_field_size() const;
  private:
  int _internal_persistent_field_size() const;
  public:
  void clear_persistent_field();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_persistent_field() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_persistent_field();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      persistent_field() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_persistent_field();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .openmatch.SearchFields search_fields = 2;
  bool has_search_fields() const;
  private:
  bool _internal_has_search_fields() const;
  public:
  void clear_search_fields();
  const ::openmatch::SearchFields& search_fields() const;
  PROTOBUF_NODISCARD ::openmatch::SearchFields* release_search_fields();
  ::openmatch::SearchFields* mutable_search_fields();
  void set_allocated_search_fields(::openmatch::SearchFields* search_fields);
  private:
  const ::openmatch::SearchFields& _internal_search_fields() const;
  ::openmatch::SearchFields* _internal_mutable_search_fields();
  public:
  void unsafe_arena_set_allocated_search_fields(
      ::openmatch::SearchFields* search_fields);
  ::openmatch::SearchFields* unsafe_arena_release_search_fields();

  // .google.protobuf.Timestamp create_time = 5;
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // int64 generation = 6;
  void clear_generation();
  int64_t generation() const;
  void set_generation(int64_t value);
  private:
  int64_t _internal_generation() const;
  void _internal_set_generation(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmatch.Backfill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Backfill_ExtensionsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Backfill_PersistentFieldEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> persistent_field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::openmatch::SearchFields* search_fields_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    int64_t generation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fmessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Ticket

// string id = 1;
inline void Ticket::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Ticket::id() const {
  // @@protoc_insertion_point(field_get:openmatch.Ticket.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ticket::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.Ticket.id)
}
inline std::string* Ticket::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:openmatch.Ticket.id)
  return _s;
}
inline const std::string& Ticket::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Ticket::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Ticket::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Ticket::release_id() {
  // @@protoc_insertion_point(field_release:openmatch.Ticket.id)
  return _impl_.id_.Release();
}
inline void Ticket::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.Ticket.id)
}

// .openmatch.Assignment assignment = 3;
inline bool Ticket::_internal_has_assignment() const {
  return this != internal_default_instance() && _impl_.assignment_ != nullptr;
}
inline bool Ticket::has_assignment() const {
  return _internal_has_assignment();
}
inline void Ticket::clear_assignment() {
  if (GetArenaForAllocation() == nullptr && _impl_.assignment_ != nullptr) {
    delete _impl_.assignment_;
  }
  _impl_.assignment_ = nullptr;
}
inline const ::openmatch::Assignment& Ticket::_internal_assignment() const {
  const ::openmatch::Assignment* p = _impl_.assignment_;
  return p != nullptr ? *p : reinterpret_cast<const ::openmatch::Assignment&>(
      ::openmatch::_Assignment_default_instance_);
}
inline const ::openmatch::Assignment& Ticket::assignment() const {
  // @@protoc_insertion_point(field_get:openmatch.Ticket.assignment)
  return _internal_assignment();
}
inline void Ticket::unsafe_arena_set_allocated_assignment(
    ::openmatch::Assignment* assignment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.assignment_);
  }
  _impl_.assignment_ = assignment;
  if (assignment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.Ticket.assignment)
}
inline ::openmatch::Assignment* Ticket::release_assignment() {
  
  ::openmatch::Assignment* temp = _impl_.assignment_;
  _impl_.assignment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openmatch::Assignment* Ticket::unsafe_arena_release_assignment() {
  // @@protoc_insertion_point(field_release:openmatch.Ticket.assignment)
  
  ::openmatch::Assignment* temp = _impl_.assignment_;
  _impl_.assignment_ = nullptr;
  return temp;
}
inline ::openmatch::Assignment* Ticket::_internal_mutable_assignment() {
  
  if (_impl_.assignment_ == nullptr) {
    auto* p = CreateMaybeMessage<::openmatch::Assignment>(GetArenaForAllocation());
    _impl_.assignment_ = p;
  }
  return _impl_.assignment_;
}
inline ::openmatch::Assignment* Ticket::mutable_assignment() {
  ::openmatch::Assignment* _msg = _internal_mutable_assignment();
  // @@protoc_insertion_point(field_mutable:openmatch.Ticket.assignment)
  return _msg;
}
inline void Ticket::set_allocated_assignment(::openmatch::Assignment* assignment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.assignment_;
  }
  if (assignment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(assignment);
    if (message_arena != submessage_arena) {
      assignment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assignment, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.assignment_ = assignment;
  // @@protoc_insertion_point(field_set_allocated:openmatch.Ticket.assignment)
}

// .openmatch.SearchFields search_fields = 4;
inline bool Ticket::_internal_has_search_fields() const {
  return this != internal_default_instance() && _impl_.search_fields_ != nullptr;
}
inline bool Ticket::has_search_fields() const {
  return _internal_has_search_fields();
}
inline void Ticket::clear_search_fields() {
  if (GetArenaForAllocation() == nullptr && _impl_.search_fields_ != nullptr) {
    delete _impl_.search_fields_;
  }
  _impl_.search_fields_ = nullptr;
}
inline const ::openmatch::SearchFields& Ticket::_internal_search_fields() const {
  const ::openmatch::SearchFields* p = _impl_.search_fields_;
  return p != nullptr ? *p : reinterpret_cast<const ::openmatch::SearchFields&>(
      ::openmatch::_SearchFields_default_instance_);
}
inline const ::openmatch::SearchFields& Ticket::search_fields() const {
  // @@protoc_insertion_point(field_get:openmatch.Ticket.search_fields)
  return _internal_search_fields();
}
inline void Ticket::unsafe_arena_set_allocated_search_fields(
    ::openmatch::SearchFields* search_fields) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.search_fields_);
  }
  _impl_.search_fields_ = search_fields;
  if (search_fields) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.Ticket.search_fields)
}
inline ::openmatch::SearchFields* Ticket::release_search_fields() {
  
  ::openmatch::SearchFields* temp = _impl_.search_fields_;
  _impl_.search_fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openmatch::SearchFields* Ticket::unsafe_arena_release_search_fields() {
  // @@protoc_insertion_point(field_release:openmatch.Ticket.search_fields)
  
  ::openmatch::SearchFields* temp = _impl_.search_fields_;
  _impl_.search_fields_ = nullptr;
  return temp;
}
inline ::openmatch::SearchFields* Ticket::_internal_mutable_search_fields() {
  
  if (_impl_.search_fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::openmatch::SearchFields>(GetArenaForAllocation());
    _impl_.search_fields_ = p;
  }
  return _impl_.search_fields_;
}
inline ::openmatch::SearchFields* Ticket::mutable_search_fields() {
  ::openmatch::SearchFields* _msg = _internal_mutable_search_fields();
  // @@protoc_insertion_point(field_mutable:openmatch.Ticket.search_fields)
  return _msg;
}
inline void Ticket::set_allocated_search_fields(::openmatch::SearchFields* search_fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.search_fields_;
  }
  if (search_fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(search_fields);
    if (message_arena != submessage_arena) {
      search_fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, search_fields, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.search_fields_ = search_fields;
  // @@protoc_insertion_point(field_set_allocated:openmatch.Ticket.search_fields)
}

// map<string, .google.protobuf.Any> extensions = 5;
inline int Ticket::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int Ticket::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Ticket::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Ticket::extensions() const {
  // @@protoc_insertion_point(field_map:openmatch.Ticket.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Ticket::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Ticket::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:openmatch.Ticket.extensions)
  return _internal_mutable_extensions();
}

// map<string, .google.protobuf.Any> persistent_field = 6;
inline int Ticket::_internal_persistent_field_size() const {
  return _impl_.persistent_field_.size();
}
inline int Ticket::persistent_field_size() const {
  return _internal_persistent_field_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Ticket::_internal_persistent_field() const {
  return _impl_.persistent_field_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Ticket::persistent_field() const {
  // @@protoc_insertion_point(field_map:openmatch.Ticket.persistent_field)
  return _internal_persistent_field();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Ticket::_internal_mutable_persistent_field() {
  return _impl_.persistent_field_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Ticket::mutable_persistent_field() {
  // @@protoc_insertion_point(field_mutable_map:openmatch.Ticket.persistent_field)
  return _internal_mutable_persistent_field();
}

// .google.protobuf.Timestamp create_time = 7;
inline bool Ticket::_internal_has_create_time() const {
  return this != internal_default_instance() && _impl_.create_time_ != nullptr;
}
inline bool Ticket::has_create_time() const {
  return _internal_has_create_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Ticket::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Ticket::create_time() const {
  // @@protoc_insertion_point(field_get:openmatch.Ticket.create_time)
  return _internal_create_time();
}
inline void Ticket::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.Ticket.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Ticket::release_create_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Ticket::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:openmatch.Ticket.create_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Ticket::_internal_mutable_create_time() {
  
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Ticket::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:openmatch.Ticket.create_time)
  return _msg;
}
inline void Ticket::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:openmatch.Ticket.create_time)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SearchFields

// map<string, double> double_args = 1;
inline int SearchFields::_internal_double_args_size() const {
  return _impl_.double_args_.size();
}
inline int SearchFields::double_args_size() const {
  return _internal_double_args_size();
}
inline void SearchFields::clear_double_args() {
  _impl_.double_args_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
SearchFields::_internal_double_args() const {
  return _impl_.double_args_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
SearchFields::double_args() const {
  // @@protoc_insertion_point(field_map:openmatch.SearchFields.double_args)
  return _internal_double_args();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
SearchFields::_internal_mutable_double_args() {
  return _impl_.double_args_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
SearchFields::mutable_double_args() {
  // @@protoc_insertion_point(field_mutable_map:openmatch.SearchFields.double_args)
  return _internal_mutable_double_args();
}

// map<string, string> string_args = 2;
inline int SearchFields::_internal_string_args_size() const {
  return _impl_.string_args_.size();
}
inline int SearchFields::string_args_size() const {
  return _internal_string_args_size();
}
inline void SearchFields::clear_string_args() {
  _impl_.string_args_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SearchFields::_internal_string_args() const {
  return _impl_.string_args_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SearchFields::string_args() const {
  // @@protoc_insertion_point(field_map:openmatch.SearchFields.string_args)
  return _internal_string_args();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SearchFields::_internal_mutable_string_args() {
  return _impl_.string_args_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SearchFields::mutable_string_args() {
  // @@protoc_insertion_point(field_mutable_map:openmatch.SearchFields.string_args)
  return _internal_mutable_string_args();
}

// repeated string tags = 3;
inline int SearchFields::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int SearchFields::tags_size() const {
  return _internal_tags_size();
}
inline void SearchFields::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* SearchFields::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:openmatch.SearchFields.tags)
  return _s;
}
inline const std::string& SearchFields::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& SearchFields::tags(int index) const {
  // @@protoc_insertion_point(field_get:openmatch.SearchFields.tags)
  return _internal_tags(index);
}
inline std::string* SearchFields::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:openmatch.SearchFields.tags)
  return _impl_.tags_.Mutable(index);
}
inline void SearchFields::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:openmatch.SearchFields.tags)
}
inline void SearchFields::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:openmatch.SearchFields.tags)
}
inline void SearchFields::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:openmatch.SearchFields.tags)
}
inline void SearchFields::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:openmatch.SearchFields.tags)
}
inline std::string* SearchFields::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void SearchFields::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:openmatch.SearchFields.tags)
}
inline void SearchFields::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:openmatch.SearchFields.tags)
}
inline void SearchFields::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:openmatch.SearchFields.tags)
}
inline void SearchFields::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:openmatch.SearchFields.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchFields::tags() const {
  // @@protoc_insertion_point(field_list:openmatch.SearchFields.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchFields::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:openmatch.SearchFields.tags)
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Assignment

// string connection = 1;
inline void Assignment::clear_connection() {
  _impl_.connection_.ClearToEmpty();
}
inline const std::string& Assignment::connection() const {
  // @@protoc_insertion_point(field_get:openmatch.Assignment.connection)
  return _internal_connection();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Assignment::set_connection(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connection_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.Assignment.connection)
}
inline std::string* Assignment::mutable_connection() {
  std::string* _s = _internal_mutable_connection();
  // @@protoc_insertion_point(field_mutable:openmatch.Assignment.connection)
  return _s;
}
inline const std::string& Assignment::_internal_connection() const {
  return _impl_.connection_.Get();
}
inline void Assignment::_internal_set_connection(const std::string& value) {
  
  _impl_.connection_.Set(value, GetArenaForAllocation());
}
inline std::string* Assignment::_internal_mutable_connection() {
  
  return _impl_.connection_.Mutable(GetArenaForAllocation());
}
inline std::string* Assignment::release_connection() {
  // @@protoc_insertion_point(field_release:openmatch.Assignment.connection)
  return _impl_.connection_.Release();
}
inline void Assignment::set_allocated_connection(std::string* connection) {
  if (connection != nullptr) {
    
  } else {
    
  }
  _impl_.connection_.SetAllocated(connection, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connection_.IsDefault()) {
    _impl_.connection_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.Assignment.connection)
}

// map<string, .google.protobuf.Any> extensions = 4;
inline int Assignment::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int Assignment::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Assignment::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Assignment::extensions() const {
  // @@protoc_insertion_point(field_map:openmatch.Assignment.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Assignment::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Assignment::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:openmatch.Assignment.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// DoubleRangeFilter

// string double_arg = 1;
inline void DoubleRangeFilter::clear_double_arg() {
  _impl_.double_arg_.ClearToEmpty();
}
inline const std::string& DoubleRangeFilter::double_arg() const {
  // @@protoc_insertion_point(field_get:openmatch.DoubleRangeFilter.double_arg)
  return _internal_double_arg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DoubleRangeFilter::set_double_arg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.double_arg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.DoubleRangeFilter.double_arg)
}
inline std::string* DoubleRangeFilter::mutable_double_arg() {
  std::string* _s = _internal_mutable_double_arg();
  // @@protoc_insertion_point(field_mutable:openmatch.DoubleRangeFilter.double_arg)
  return _s;
}
inline const std::string& DoubleRangeFilter::_internal_double_arg() const {
  return _impl_.double_arg_.Get();
}
inline void DoubleRangeFilter::_internal_set_double_arg(const std::string& value) {
  
  _impl_.double_arg_.Set(value, GetArenaForAllocation());
}
inline std::string* DoubleRangeFilter::_internal_mutable_double_arg() {
  
  return _impl_.double_arg_.Mutable(GetArenaForAllocation());
}
inline std::string* DoubleRangeFilter::release_double_arg() {
  // @@protoc_insertion_point(field_release:openmatch.DoubleRangeFilter.double_arg)
  return _impl_.double_arg_.Release();
}
inline void DoubleRangeFilter::set_allocated_double_arg(std::string* double_arg) {
  if (double_arg != nullptr) {
    
  } else {
    
  }
  _impl_.double_arg_.SetAllocated(double_arg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.double_arg_.IsDefault()) {
    _impl_.double_arg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.DoubleRangeFilter.double_arg)
}

// double max = 2;
inline void DoubleRangeFilter::clear_max() {
  _impl_.max_ = 0;
}
inline double DoubleRangeFilter::_internal_max() const {
  return _impl_.max_;
}
inline double DoubleRangeFilter::max() const {
  // @@protoc_insertion_point(field_get:openmatch.DoubleRangeFilter.max)
  return _internal_max();
}
inline void DoubleRangeFilter::_internal_set_max(double value) {
  
  _impl_.max_ = value;
}
inline void DoubleRangeFilter::set_max(double value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:openmatch.DoubleRangeFilter.max)
}

// double min = 3;
inline void DoubleRangeFilter::clear_min() {
  _impl_.min_ = 0;
}
inline double DoubleRangeFilter::_internal_min() const {
  return _impl_.min_;
}
inline double DoubleRangeFilter::min() const {
  // @@protoc_insertion_point(field_get:openmatch.DoubleRangeFilter.min)
  return _internal_min();
}
inline void DoubleRangeFilter::_internal_set_min(double value) {
  
  _impl_.min_ = value;
}
inline void DoubleRangeFilter::set_min(double value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:openmatch.DoubleRangeFilter.min)
}

// .openmatch.DoubleRangeFilter.Exclude exclude = 4;
inline void DoubleRangeFilter::clear_exclude() {
  _impl_.exclude_ = 0;
}
inline ::openmatch::DoubleRangeFilter_Exclude DoubleRangeFilter::_internal_exclude() const {
  return static_cast< ::openmatch::DoubleRangeFilter_Exclude >(_impl_.exclude_);
}
inline ::openmatch::DoubleRangeFilter_Exclude DoubleRangeFilter::exclude() const {
  // @@protoc_insertion_point(field_get:openmatch.DoubleRangeFilter.exclude)
  return _internal_exclude();
}
inline void DoubleRangeFilter::_internal_set_exclude(::openmatch::DoubleRangeFilter_Exclude value) {
  
  _impl_.exclude_ = value;
}
inline void DoubleRangeFilter::set_exclude(::openmatch::DoubleRangeFilter_Exclude value) {
  _internal_set_exclude(value);
  // @@protoc_insertion_point(field_set:openmatch.DoubleRangeFilter.exclude)
}

// -------------------------------------------------------------------

// StringEqualsFilter

// string string_arg = 1;
inline void StringEqualsFilter::clear_string_arg() {
  _impl_.string_arg_.ClearToEmpty();
}
inline const std::string& StringEqualsFilter::string_arg() const {
  // @@protoc_insertion_point(field_get:openmatch.StringEqualsFilter.string_arg)
  return _internal_string_arg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringEqualsFilter::set_string_arg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.string_arg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.StringEqualsFilter.string_arg)
}
inline std::string* StringEqualsFilter::mutable_string_arg() {
  std::string* _s = _internal_mutable_string_arg();
  // @@protoc_insertion_point(field_mutable:openmatch.StringEqualsFilter.string_arg)
  return _s;
}
inline const std::string& StringEqualsFilter::_internal_string_arg() const {
  return _impl_.string_arg_.Get();
}
inline void StringEqualsFilter::_internal_set_string_arg(const std::string& value) {
  
  _impl_.string_arg_.Set(value, GetArenaForAllocation());
}
inline std::string* StringEqualsFilter::_internal_mutable_string_arg() {
  
  return _impl_.string_arg_.Mutable(GetArenaForAllocation());
}
inline std::string* StringEqualsFilter::release_string_arg() {
  // @@protoc_insertion_point(field_release:openmatch.StringEqualsFilter.string_arg)
  return _impl_.string_arg_.Release();
}
inline void StringEqualsFilter::set_allocated_string_arg(std::string* string_arg) {
  if (string_arg != nullptr) {
    
  } else {
    
  }
  _impl_.string_arg_.SetAllocated(string_arg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.string_arg_.IsDefault()) {
    _impl_.string_arg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.StringEqualsFilter.string_arg)
}

// string value = 2;
inline void StringEqualsFilter::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& StringEqualsFilter::value() const {
  // @@protoc_insertion_point(field_get:openmatch.StringEqualsFilter.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringEqualsFilter::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.StringEqualsFilter.value)
}
inline std::string* StringEqualsFilter::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:openmatch.StringEqualsFilter.value)
  return _s;
}
inline const std::string& StringEqualsFilter::_internal_value() const {
  return _impl_.value_.Get();
}
inline void StringEqualsFilter::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* StringEqualsFilter::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* StringEqualsFilter::release_value() {
  // @@protoc_insertion_point(field_release:openmatch.StringEqualsFilter.value)
  return _impl_.value_.Release();
}
inline void StringEqualsFilter::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.StringEqualsFilter.value)
}

// -------------------------------------------------------------------

// TagPresentFilter

// string tag = 1;
inline void TagPresentFilter::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& TagPresentFilter::tag() const {
  // @@protoc_insertion_point(field_get:openmatch.TagPresentFilter.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagPresentFilter::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.TagPresentFilter.tag)
}
inline std::string* TagPresentFilter::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:openmatch.TagPresentFilter.tag)
  return _s;
}
inline const std::string& TagPresentFilter::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void TagPresentFilter::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* TagPresentFilter::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* TagPresentFilter::release_tag() {
  // @@protoc_insertion_point(field_release:openmatch.TagPresentFilter.tag)
  return _impl_.tag_.Release();
}
inline void TagPresentFilter::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.TagPresentFilter.tag)
}

// -------------------------------------------------------------------

// Pool

// string name = 1;
inline void Pool::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Pool::name() const {
  // @@protoc_insertion_point(field_get:openmatch.Pool.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pool::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.Pool.name)
}
inline std::string* Pool::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openmatch.Pool.name)
  return _s;
}
inline const std::string& Pool::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Pool::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Pool::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Pool::release_name() {
  // @@protoc_insertion_point(field_release:openmatch.Pool.name)
  return _impl_.name_.Release();
}
inline void Pool::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.Pool.name)
}

// repeated .openmatch.DoubleRangeFilter double_range_filters = 2;
inline int Pool::_internal_double_range_filters_size() const {
  return _impl_.double_range_filters_.size();
}
inline int Pool::double_range_filters_size() const {
  return _internal_double_range_filters_size();
}
inline void Pool::clear_double_range_filters() {
  _impl_.double_range_filters_.Clear();
}
inline ::openmatch::DoubleRangeFilter* Pool::mutable_double_range_filters(int index) {
  // @@protoc_insertion_point(field_mutable:openmatch.Pool.double_range_filters)
  return _impl_.double_range_filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::DoubleRangeFilter >*
Pool::mutable_double_range_filters() {
  // @@protoc_insertion_point(field_mutable_list:openmatch.Pool.double_range_filters)
  return &_impl_.double_range_filters_;
}
inline const ::openmatch::DoubleRangeFilter& Pool::_internal_double_range_filters(int index) const {
  return _impl_.double_range_filters_.Get(index);
}
inline const ::openmatch::DoubleRangeFilter& Pool::double_range_filters(int index) const {
  // @@protoc_insertion_point(field_get:openmatch.Pool.double_range_filters)
  return _internal_double_range_filters(index);
}
inline ::openmatch::DoubleRangeFilter* Pool::_internal_add_double_range_filters() {
  return _impl_.double_range_filters_.Add();
}
inline ::openmatch::DoubleRangeFilter* Pool::add_double_range_filters() {
  ::openmatch::DoubleRangeFilter* _add = _internal_add_double_range_filters();
  // @@protoc_insertion_point(field_add:openmatch.Pool.double_range_filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::DoubleRangeFilter >&
Pool::double_range_filters() const {
  // @@protoc_insertion_point(field_list:openmatch.Pool.double_range_filters)
  return _impl_.double_range_filters_;
}

// repeated .openmatch.StringEqualsFilter string_equals_filters = 4;
inline int Pool::_internal_string_equals_filters_size() const {
  return _impl_.string_equals_filters_.size();
}
inline int Pool::string_equals_filters_size() const {
  return _internal_string_equals_filters_size();
}
inline void Pool::clear_string_equals_filters() {
  _impl_.string_equals_filters_.Clear();
}
inline ::openmatch::StringEqualsFilter* Pool::mutable_string_equals_filters(int index) {
  // @@protoc_insertion_point(field_mutable:openmatch.Pool.string_equals_filters)
  return _impl_.string_equals_filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::StringEqualsFilter >*
Pool::mutable_string_equals_filters() {
  // @@protoc_insertion_point(field_mutable_list:openmatch.Pool.string_equals_filters)
  return &_impl_.string_equals_filters_;
}
inline const ::openmatch::StringEqualsFilter& Pool::_internal_string_equals_filters(int index) const {
  return _impl_.string_equals_filters_.Get(index);
}
inline const ::openmatch::StringEqualsFilter& Pool::string_equals_filters(int index) const {
  // @@protoc_insertion_point(field_get:openmatch.Pool.string_equals_filters)
  return _internal_string_equals_filters(index);
}
inline ::openmatch::StringEqualsFilter* Pool::_internal_add_string_equals_filters() {
  return _impl_.string_equals_filters_.Add();
}
inline ::openmatch::StringEqualsFilter* Pool::add_string_equals_filters() {
  ::openmatch::StringEqualsFilter* _add = _internal_add_string_equals_filters();
  // @@protoc_insertion_point(field_add:openmatch.Pool.string_equals_filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::StringEqualsFilter >&
Pool::string_equals_filters() const {
  // @@protoc_insertion_point(field_list:openmatch.Pool.string_equals_filters)
  return _impl_.string_equals_filters_;
}

// repeated .openmatch.TagPresentFilter tag_present_filters = 5;
inline int Pool::_internal_tag_present_filters_size() const {
  return _impl_.tag_present_filters_.size();
}
inline int Pool::tag_present_filters_size() const {
  return _internal_tag_present_filters_size();
}
inline void Pool::clear_tag_present_filters() {
  _impl_.tag_present_filters_.Clear();
}
inline ::openmatch::TagPresentFilter* Pool::mutable_tag_present_filters(int index) {
  // @@protoc_insertion_point(field_mutable:openmatch.Pool.tag_present_filters)
  return _impl_.tag_present_filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::TagPresentFilter >*
Pool::mutable_tag_present_filters() {
  // @@protoc_insertion_point(field_mutable_list:openmatch.Pool.tag_present_filters)
  return &_impl_.tag_present_filters_;
}
inline const ::openmatch::TagPresentFilter& Pool::_internal_tag_present_filters(int index) const {
  return _impl_.tag_present_filters_.Get(index);
}
inline const ::openmatch::TagPresentFilter& Pool::tag_present_filters(int index) const {
  // @@protoc_insertion_point(field_get:openmatch.Pool.tag_present_filters)
  return _internal_tag_present_filters(index);
}
inline ::openmatch::TagPresentFilter* Pool::_internal_add_tag_present_filters() {
  return _impl_.tag_present_filters_.Add();
}
inline ::openmatch::TagPresentFilter* Pool::add_tag_present_filters() {
  ::openmatch::TagPresentFilter* _add = _internal_add_tag_present_filters();
  // @@protoc_insertion_point(field_add:openmatch.Pool.tag_present_filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::TagPresentFilter >&
Pool::tag_present_filters() const {
  // @@protoc_insertion_point(field_list:openmatch.Pool.tag_present_filters)
  return _impl_.tag_present_filters_;
}

// .google.protobuf.Timestamp created_before = 6;
inline bool Pool::_internal_has_created_before() const {
  return this != internal_default_instance() && _impl_.created_before_ != nullptr;
}
inline bool Pool::has_created_before() const {
  return _internal_has_created_before();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Pool::_internal_created_before() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_before_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Pool::created_before() const {
  // @@protoc_insertion_point(field_get:openmatch.Pool.created_before)
  return _internal_created_before();
}
inline void Pool::unsafe_arena_set_allocated_created_before(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_before) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_before_);
  }
  _impl_.created_before_ = created_before;
  if (created_before) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.Pool.created_before)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Pool::release_created_before() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_before_;
  _impl_.created_before_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Pool::unsafe_arena_release_created_before() {
  // @@protoc_insertion_point(field_release:openmatch.Pool.created_before)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_before_;
  _impl_.created_before_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Pool::_internal_mutable_created_before() {
  
  if (_impl_.created_before_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_before_ = p;
  }
  return _impl_.created_before_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Pool::mutable_created_before() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_before();
  // @@protoc_insertion_point(field_mutable:openmatch.Pool.created_before)
  return _msg;
}
inline void Pool::set_allocated_created_before(::PROTOBUF_NAMESPACE_ID::Timestamp* created_before) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_before_);
  }
  if (created_before) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_before));
    if (message_arena != submessage_arena) {
      created_before = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_before, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_before_ = created_before;
  // @@protoc_insertion_point(field_set_allocated:openmatch.Pool.created_before)
}

// .google.protobuf.Timestamp created_after = 7;
inline bool Pool::_internal_has_created_after() const {
  return this != internal_default_instance() && _impl_.created_after_ != nullptr;
}
inline bool Pool::has_created_after() const {
  return _internal_has_created_after();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Pool::_internal_created_after() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_after_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Pool::created_after() const {
  // @@protoc_insertion_point(field_get:openmatch.Pool.created_after)
  return _internal_created_after();
}
inline void Pool::unsafe_arena_set_allocated_created_after(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_after) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_after_);
  }
  _impl_.created_after_ = created_after;
  if (created_after) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.Pool.created_after)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Pool::release_created_after() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_after_;
  _impl_.created_after_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Pool::unsafe_arena_release_created_after() {
  // @@protoc_insertion_point(field_release:openmatch.Pool.created_after)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_after_;
  _impl_.created_after_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Pool::_internal_mutable_created_after() {
  
  if (_impl_.created_after_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_after_ = p;
  }
  return _impl_.created_after_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Pool::mutable_created_after() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_after();
  // @@protoc_insertion_point(field_mutable:openmatch.Pool.created_after)
  return _msg;
}
inline void Pool::set_allocated_created_after(::PROTOBUF_NAMESPACE_ID::Timestamp* created_after) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_after_);
  }
  if (created_after) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_after));
    if (message_arena != submessage_arena) {
      created_after = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_after, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_after_ = created_after;
  // @@protoc_insertion_point(field_set_allocated:openmatch.Pool.created_after)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MatchProfile

// string name = 1;
inline void MatchProfile::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MatchProfile::name() const {
  // @@protoc_insertion_point(field_get:openmatch.MatchProfile.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchProfile::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.MatchProfile.name)
}
inline std::string* MatchProfile::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openmatch.MatchProfile.name)
  return _s;
}
inline const std::string& MatchProfile::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MatchProfile::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchProfile::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchProfile::release_name() {
  // @@protoc_insertion_point(field_release:openmatch.MatchProfile.name)
  return _impl_.name_.Release();
}
inline void MatchProfile::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.MatchProfile.name)
}

// repeated .openmatch.Pool pools = 3;
inline int MatchProfile::_internal_pools_size() const {
  return _impl_.pools_.size();
}
inline int MatchProfile::pools_size() const {
  return _internal_pools_size();
}
inline void MatchProfile::clear_pools() {
  _impl_.pools_.Clear();
}
inline ::openmatch::Pool* MatchProfile::mutable_pools(int index) {
  // @@protoc_insertion_point(field_mutable:openmatch.MatchProfile.pools)
  return _impl_.pools_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Pool >*
MatchProfile::mutable_pools() {
  // @@protoc_insertion_point(field_mutable_list:openmatch.MatchProfile.pools)
  return &_impl_.pools_;
}
inline const ::openmatch::Pool& MatchProfile::_internal_pools(int index) const {
  return _impl_.pools_.Get(index);
}
inline const ::openmatch::Pool& MatchProfile::pools(int index) const {
  // @@protoc_insertion_point(field_get:openmatch.MatchProfile.pools)
  return _internal_pools(index);
}
inline ::openmatch::Pool* MatchProfile::_internal_add_pools() {
  return _impl_.pools_.Add();
}
inline ::openmatch::Pool* MatchProfile::add_pools() {
  ::openmatch::Pool* _add = _internal_add_pools();
  // @@protoc_insertion_point(field_add:openmatch.MatchProfile.pools)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Pool >&
MatchProfile::pools() const {
  // @@protoc_insertion_point(field_list:openmatch.MatchProfile.pools)
  return _impl_.pools_;
}

// map<string, .google.protobuf.Any> extensions = 5;
inline int MatchProfile::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int MatchProfile::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
MatchProfile::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
MatchProfile::extensions() const {
  // @@protoc_insertion_point(field_map:openmatch.MatchProfile.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
MatchProfile::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
MatchProfile::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:openmatch.MatchProfile.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Match

// string match_id = 1;
inline void Match::clear_match_id() {
  _impl_.match_id_.ClearToEmpty();
}
inline const std::string& Match::match_id() const {
  // @@protoc_insertion_point(field_get:openmatch.Match.match_id)
  return _internal_match_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Match::set_match_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.match_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.Match.match_id)
}
inline std::string* Match::mutable_match_id() {
  std::string* _s = _internal_mutable_match_id();
  // @@protoc_insertion_point(field_mutable:openmatch.Match.match_id)
  return _s;
}
inline const std::string& Match::_internal_match_id() const {
  return _impl_.match_id_.Get();
}
inline void Match::_internal_set_match_id(const std::string& value) {
  
  _impl_.match_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Match::_internal_mutable_match_id() {
  
  return _impl_.match_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Match::release_match_id() {
  // @@protoc_insertion_point(field_release:openmatch.Match.match_id)
  return _impl_.match_id_.Release();
}
inline void Match::set_allocated_match_id(std::string* match_id) {
  if (match_id != nullptr) {
    
  } else {
    
  }
  _impl_.match_id_.SetAllocated(match_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.match_id_.IsDefault()) {
    _impl_.match_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.Match.match_id)
}

// string match_profile = 2;
inline void Match::clear_match_profile() {
  _impl_.match_profile_.ClearToEmpty();
}
inline const std::string& Match::match_profile() const {
  // @@protoc_insertion_point(field_get:openmatch.Match.match_profile)
  return _internal_match_profile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Match::set_match_profile(ArgT0&& arg0, ArgT... args) {
 
 _impl_.match_profile_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.Match.match_profile)
}
inline std::string* Match::mutable_match_profile() {
  std::string* _s = _internal_mutable_match_profile();
  // @@protoc_insertion_point(field_mutable:openmatch.Match.match_profile)
  return _s;
}
inline const std::string& Match::_internal_match_profile() const {
  return _impl_.match_profile_.Get();
}
inline void Match::_internal_set_match_profile(const std::string& value) {
  
  _impl_.match_profile_.Set(value, GetArenaForAllocation());
}
inline std::string* Match::_internal_mutable_match_profile() {
  
  return _impl_.match_profile_.Mutable(GetArenaForAllocation());
}
inline std::string* Match::release_match_profile() {
  // @@protoc_insertion_point(field_release:openmatch.Match.match_profile)
  return _impl_.match_profile_.Release();
}
inline void Match::set_allocated_match_profile(std::string* match_profile) {
  if (match_profile != nullptr) {
    
  } else {
    
  }
  _impl_.match_profile_.SetAllocated(match_profile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.match_profile_.IsDefault()) {
    _impl_.match_profile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.Match.match_profile)
}

// string match_function = 3;
inline void Match::clear_match_function() {
  _impl_.match_function_.ClearToEmpty();
}
inline const std::string& Match::match_function() const {
  // @@protoc_insertion_point(field_get:openmatch.Match.match_function)
  return _internal_match_function();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Match::set_match_function(ArgT0&& arg0, ArgT... args) {
 
 _impl_.match_function_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.Match.match_function)
}
inline std::string* Match::mutable_match_function() {
  std::string* _s = _internal_mutable_match_function();
  // @@protoc_insertion_point(field_mutable:openmatch.Match.match_function)
  return _s;
}
inline const std::string& Match::_internal_match_function() const {
  return _impl_.match_function_.Get();
}
inline void Match::_internal_set_match_function(const std::string& value) {
  
  _impl_.match_function_.Set(value, GetArenaForAllocation());
}
inline std::string* Match::_internal_mutable_match_function() {
  
  return _impl_.match_function_.Mutable(GetArenaForAllocation());
}
inline std::string* Match::release_match_function() {
  // @@protoc_insertion_point(field_release:openmatch.Match.match_function)
  return _impl_.match_function_.Release();
}
inline void Match::set_allocated_match_function(std::string* match_function) {
  if (match_function != nullptr) {
    
  } else {
    
  }
  _impl_.match_function_.SetAllocated(match_function, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.match_function_.IsDefault()) {
    _impl_.match_function_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.Match.match_function)
}

// repeated .openmatch.Ticket tickets = 4;
inline int Match::_internal_tickets_size() const {
  return _impl_.tickets_.size();
}
inline int Match::tickets_size() const {
  return _internal_tickets_size();
}
inline void Match::clear_tickets() {
  _impl_.tickets_.Clear();
}
inline ::openmatch::Ticket* Match::mutable_tickets(int index) {
  // @@protoc_insertion_point(field_mutable:openmatch.Match.tickets)
  return _impl_.tickets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Ticket >*
Match::mutable_tickets() {
  // @@protoc_insertion_point(field_mutable_list:openmatch.Match.tickets)
  return &_impl_.tickets_;
}
inline const ::openmatch::Ticket& Match::_internal_tickets(int index) const {
  return _impl_.tickets_.Get(index);
}
inline const ::openmatch::Ticket& Match::tickets(int index) const {
  // @@protoc_insertion_point(field_get:openmatch.Match.tickets)
  return _internal_tickets(index);
}
inline ::openmatch::Ticket* Match::_internal_add_tickets() {
  return _impl_.tickets_.Add();
}
inline ::openmatch::Ticket* Match::add_tickets() {
  ::openmatch::Ticket* _add = _internal_add_tickets();
  // @@protoc_insertion_point(field_add:openmatch.Match.tickets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmatch::Ticket >&
Match::tickets() const {
  // @@protoc_insertion_point(field_list:openmatch.Match.tickets)
  return _impl_.tickets_;
}

// map<string, .google.protobuf.Any> extensions = 7;
inline int Match::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int Match::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Match::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Match::extensions() const {
  // @@protoc_insertion_point(field_map:openmatch.Match.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Match::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Match::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:openmatch.Match.extensions)
  return _internal_mutable_extensions();
}

// .openmatch.Backfill backfill = 8;
inline bool Match::_internal_has_backfill() const {
  return this != internal_default_instance() && _impl_.backfill_ != nullptr;
}
inline bool Match::has_backfill() const {
  return _internal_has_backfill();
}
inline void Match::clear_backfill() {
  if (GetArenaForAllocation() == nullptr && _impl_.backfill_ != nullptr) {
    delete _impl_.backfill_;
  }
  _impl_.backfill_ = nullptr;
}
inline const ::openmatch::Backfill& Match::_internal_backfill() const {
  const ::openmatch::Backfill* p = _impl_.backfill_;
  return p != nullptr ? *p : reinterpret_cast<const ::openmatch::Backfill&>(
      ::openmatch::_Backfill_default_instance_);
}
inline const ::openmatch::Backfill& Match::backfill() const {
  // @@protoc_insertion_point(field_get:openmatch.Match.backfill)
  return _internal_backfill();
}
inline void Match::unsafe_arena_set_allocated_backfill(
    ::openmatch::Backfill* backfill) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.backfill_);
  }
  _impl_.backfill_ = backfill;
  if (backfill) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.Match.backfill)
}
inline ::openmatch::Backfill* Match::release_backfill() {
  
  ::openmatch::Backfill* temp = _impl_.backfill_;
  _impl_.backfill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openmatch::Backfill* Match::unsafe_arena_release_backfill() {
  // @@protoc_insertion_point(field_release:openmatch.Match.backfill)
  
  ::openmatch::Backfill* temp = _impl_.backfill_;
  _impl_.backfill_ = nullptr;
  return temp;
}
inline ::openmatch::Backfill* Match::_internal_mutable_backfill() {
  
  if (_impl_.backfill_ == nullptr) {
    auto* p = CreateMaybeMessage<::openmatch::Backfill>(GetArenaForAllocation());
    _impl_.backfill_ = p;
  }
  return _impl_.backfill_;
}
inline ::openmatch::Backfill* Match::mutable_backfill() {
  ::openmatch::Backfill* _msg = _internal_mutable_backfill();
  // @@protoc_insertion_point(field_mutable:openmatch.Match.backfill)
  return _msg;
}
inline void Match::set_allocated_backfill(::openmatch::Backfill* backfill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.backfill_;
  }
  if (backfill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(backfill);
    if (message_arena != submessage_arena) {
      backfill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backfill, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.backfill_ = backfill;
  // @@protoc_insertion_point(field_set_allocated:openmatch.Match.backfill)
}

// bool allocate_gameserver = 9;
inline void Match::clear_allocate_gameserver() {
  _impl_.allocate_gameserver_ = false;
}
inline bool Match::_internal_allocate_gameserver() const {
  return _impl_.allocate_gameserver_;
}
inline bool Match::allocate_gameserver() const {
  // @@protoc_insertion_point(field_get:openmatch.Match.allocate_gameserver)
  return _internal_allocate_gameserver();
}
inline void Match::_internal_set_allocate_gameserver(bool value) {
  
  _impl_.allocate_gameserver_ = value;
}
inline void Match::set_allocate_gameserver(bool value) {
  _internal_set_allocate_gameserver(value);
  // @@protoc_insertion_point(field_set:openmatch.Match.allocate_gameserver)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Backfill

// string id = 1;
inline void Backfill::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Backfill::id() const {
  // @@protoc_insertion_point(field_get:openmatch.Backfill.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backfill::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmatch.Backfill.id)
}
inline std::string* Backfill::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:openmatch.Backfill.id)
  return _s;
}
inline const std::string& Backfill::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Backfill::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Backfill::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Backfill::release_id() {
  // @@protoc_insertion_point(field_release:openmatch.Backfill.id)
  return _impl_.id_.Release();
}
inline void Backfill::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmatch.Backfill.id)
}

// .openmatch.SearchFields search_fields = 2;
inline bool Backfill::_internal_has_search_fields() const {
  return this != internal_default_instance() && _impl_.search_fields_ != nullptr;
}
inline bool Backfill::has_search_fields() const {
  return _internal_has_search_fields();
}
inline void Backfill::clear_search_fields() {
  if (GetArenaForAllocation() == nullptr && _impl_.search_fields_ != nullptr) {
    delete _impl_.search_fields_;
  }
  _impl_.search_fields_ = nullptr;
}
inline const ::openmatch::SearchFields& Backfill::_internal_search_fields() const {
  const ::openmatch::SearchFields* p = _impl_.search_fields_;
  return p != nullptr ? *p : reinterpret_cast<const ::openmatch::SearchFields&>(
      ::openmatch::_SearchFields_default_instance_);
}
inline const ::openmatch::SearchFields& Backfill::search_fields() const {
  // @@protoc_insertion_point(field_get:openmatch.Backfill.search_fields)
  return _internal_search_fields();
}
inline void Backfill::unsafe_arena_set_allocated_search_fields(
    ::openmatch::SearchFields* search_fields) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.search_fields_);
  }
  _impl_.search_fields_ = search_fields;
  if (search_fields) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.Backfill.search_fields)
}
inline ::openmatch::SearchFields* Backfill::release_search_fields() {
  
  ::openmatch::SearchFields* temp = _impl_.search_fields_;
  _impl_.search_fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openmatch::SearchFields* Backfill::unsafe_arena_release_search_fields() {
  // @@protoc_insertion_point(field_release:openmatch.Backfill.search_fields)
  
  ::openmatch::SearchFields* temp = _impl_.search_fields_;
  _impl_.search_fields_ = nullptr;
  return temp;
}
inline ::openmatch::SearchFields* Backfill::_internal_mutable_search_fields() {
  
  if (_impl_.search_fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::openmatch::SearchFields>(GetArenaForAllocation());
    _impl_.search_fields_ = p;
  }
  return _impl_.search_fields_;
}
inline ::openmatch::SearchFields* Backfill::mutable_search_fields() {
  ::openmatch::SearchFields* _msg = _internal_mutable_search_fields();
  // @@protoc_insertion_point(field_mutable:openmatch.Backfill.search_fields)
  return _msg;
}
inline void Backfill::set_allocated_search_fields(::openmatch::SearchFields* search_fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.search_fields_;
  }
  if (search_fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(search_fields);
    if (message_arena != submessage_arena) {
      search_fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, search_fields, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.search_fields_ = search_fields;
  // @@protoc_insertion_point(field_set_allocated:openmatch.Backfill.search_fields)
}

// map<string, .google.protobuf.Any> extensions = 3;
inline int Backfill::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int Backfill::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Backfill::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Backfill::extensions() const {
  // @@protoc_insertion_point(field_map:openmatch.Backfill.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Backfill::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Backfill::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:openmatch.Backfill.extensions)
  return _internal_mutable_extensions();
}

// map<string, .google.protobuf.Any> persistent_field = 4;
inline int Backfill::_internal_persistent_field_size() const {
  return _impl_.persistent_field_.size();
}
inline int Backfill::persistent_field_size() const {
  return _internal_persistent_field_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Backfill::_internal_persistent_field() const {
  return _impl_.persistent_field_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Backfill::persistent_field() const {
  // @@protoc_insertion_point(field_map:openmatch.Backfill.persistent_field)
  return _internal_persistent_field();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Backfill::_internal_mutable_persistent_field() {
  return _impl_.persistent_field_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Backfill::mutable_persistent_field() {
  // @@protoc_insertion_point(field_mutable_map:openmatch.Backfill.persistent_field)
  return _internal_mutable_persistent_field();
}

// .google.protobuf.Timestamp create_time = 5;
inline bool Backfill::_internal_has_create_time() const {
  return this != internal_default_instance() && _impl_.create_time_ != nullptr;
}
inline bool Backfill::has_create_time() const {
  return _internal_has_create_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Backfill::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Backfill::create_time() const {
  // @@protoc_insertion_point(field_get:openmatch.Backfill.create_time)
  return _internal_create_time();
}
inline void Backfill::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openmatch.Backfill.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backfill::release_create_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backfill::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:openmatch.Backfill.create_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backfill::_internal_mutable_create_time() {
  
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backfill::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:openmatch.Backfill.create_time)
  return _msg;
}
inline void Backfill::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:openmatch.Backfill.create_time)
}

// int64 generation = 6;
inline void Backfill::clear_generation() {
  _impl_.generation_ = int64_t{0};
}
inline int64_t Backfill::_internal_generation() const {
  return _impl_.generation_;
}
inline int64_t Backfill::generation() const {
  // @@protoc_insertion_point(field_get:openmatch.Backfill.generation)
  return _internal_generation();
}
inline void Backfill::_internal_set_generation(int64_t value) {
  
  _impl_.generation_ = value;
}
inline void Backfill::set_generation(int64_t value) {
  _internal_set_generation(value);
  // @@protoc_insertion_point(field_set:openmatch.Backfill.generation)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace openmatch

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::openmatch::DoubleRangeFilter_Exclude> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openmatch::DoubleRangeFilter_Exclude>() {
  return ::openmatch::DoubleRangeFilter_Exclude_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_api_2fmessages_2eproto
